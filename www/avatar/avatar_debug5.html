<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Avatar Streaming</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .container {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        #avatarVideo {
            width: 100%;
            max-width: 640px;
            background: #000;
            border-radius: 5px;
        }
        .status {
            margin: 20px 0;
            padding: 15px;
            background: #333;
            border-radius: 5px;
            font-family: monospace;
        }
        .status.error {
            background: #4a1a1a;
            color: #ff6b6b;
        }
        .status.success {
            background: #1a4a1a;
            color: #6bff6b;
        }
        .controls {
            margin: 20px 0;
        }
        button {
            background: #4a4a4a;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background: #5a5a5a;
        }
        button.primary {
            background: #2563eb;
        }
        button.primary:hover {
            background: #3b82f6;
        }
        .debug-log {
            background: #1a1a1a;
            padding: 10px;
            border-radius: 5px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
        }
        .chunk-indicator {
            display: inline-block;
            width: 30px;
            height: 30px;
            margin: 2px;
            background: #4a4a4a;
            border-radius: 3px;
            text-align: center;
            line-height: 30px;
            font-size: 12px;
        }
        .chunk-indicator.loaded {
            background: #3b82f6;
        }
        .chunk-indicator.playing {
            background: #10b981;
            animation: pulse 1s infinite;
        }
        .chunk-indicator.error {
            background: #ef4444;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #10b981);
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Fixed Avatar Video Streaming</h1>

    <div id="videoContainer">
        <video id="avatarVideo" controls></video>
    </div>

    <div class="status" id="status">
        Ready to start streaming...
    </div>

    <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
    </div>

    <div id="chunkIndicators"></div>

    <div class="controls">
        <button class="primary" onclick="startStreaming()">Start Streaming Test</button>
        <button onclick="clearVideo()">Clear</button>
        <button onclick="toggleDebug()">Toggle Debug</button>
    </div>

    <div class="debug-log" id="debugLog" style="display: none;"></div>
</div>

<script>
    // Enhanced streaming processor with proper MediaSource handling
    class VideoStreamProcessor {
        constructor(videoElement) {
            this.video = videoElement;
            this.mediaSource = null;
            this.sourceBuffer = null;
            this.chunks = [];
            this.pendingChunks = [];
            this.currentChunkIndex = 0;
            this.isInitialized = false;
            this.isAppending = false;
            this.streamComplete = false;
            this.chunkIndicators = [];

            // Codec configuration
            this.mimeType = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';

            this.log('Stream processor initialized');
        }

        log(message, data = null) {
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            const logMessage = `[${timestamp}] ${message}${data ? ': ' + JSON.stringify(data) : ''}`;
            console.log(logMessage);

            const debugLog = document.getElementById('debugLog');
            if (debugLog) {
                debugLog.textContent += logMessage + '\n';
                debugLog.scrollTop = debugLog.scrollHeight;
            }
        }

        updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            if (status) {
                status.textContent = message;
                status.className = `status ${type}`;
            }
        }

        async initialize() {
            if (this.isInitialized) return;

            try {
                // Check MediaSource support
                if (!window.MediaSource) {
                    throw new Error('MediaSource API not supported');
                }

                // Check codec support
                if (!MediaSource.isTypeSupported(this.mimeType)) {
                    // Try alternative codecs
                    const alternativeCodecs = [
                        'video/mp4; codecs="avc1.640028"',
                        'video/mp4; codecs="avc1.42E01E"',
                        'video/webm; codecs="vp8, vorbis"',
                        'video/webm; codecs="vp9"'
                    ];

                    let supported = false;
                    for (const codec of alternativeCodecs) {
                        if (MediaSource.isTypeSupported(codec)) {
                            this.mimeType = codec;
                            supported = true;
                            this.log('Using alternative codec', codec);
                            break;
                        }
                    }

                    if (!supported) {
                        throw new Error('No supported video codec found');
                    }
                }

                this.mediaSource = new MediaSource();
                this.video.src = URL.createObjectURL(this.mediaSource);

                await new Promise((resolve, reject) => {
                    this.mediaSource.addEventListener('sourceopen', () => {
                        this.log('MediaSource opened');
                        resolve();
                    }, { once: true });

                    this.mediaSource.addEventListener('error', (e) => {
                        this.log('MediaSource error', e);
                        reject(e);
                    }, { once: true });
                });

                // Create source buffer
                this.sourceBuffer = this.mediaSource.addSourceBuffer(this.mimeType);

                // Set up source buffer event handlers
                this.sourceBuffer.addEventListener('updateend', () => {
                    this.isAppending = false;
                    this.processPendingChunks();
                });

                this.sourceBuffer.addEventListener('error', (e) => {
                    this.log('SourceBuffer error', e);
                    this.updateStatus('Buffer error occurred', 'error');
                });

                this.isInitialized = true;
                this.updateStatus('Stream initialized and ready', 'success');
                this.log('Initialization complete');

            } catch (error) {
                this.log('Initialization error', error.message);
                this.updateStatus(`Failed to initialize: ${error.message}`, 'error');

                // Fallback to blob-based playback
                this.fallbackToBlob();
            }
        }

        async processChunk(chunkData) {
            const chunkInfo = {
                id: chunkData.id || this.chunks.length,
                data: chunkData.data,
                duration: chunkData.duration || 2,
                timestamp: Date.now()
            };

            this.chunks.push(chunkInfo);
            this.log(`Chunk ${chunkInfo.id} received`, {
                dataLength: chunkInfo.data.length,
                duration: chunkInfo.duration
            });

            // Update chunk indicators
            this.updateChunkIndicator(chunkInfo.id, 'loaded');

            // Initialize on first chunk
            if (!this.isInitialized) {
                await this.initialize();
            }

            // Convert base64 to ArrayBuffer
            const arrayBuffer = await this.base64ToArrayBuffer(chunkInfo.data);
            if (!arrayBuffer) {
                this.log(`Failed to decode chunk ${chunkInfo.id}`);
                this.updateChunkIndicator(chunkInfo.id, 'error');
                return;
            }

            // Add to pending queue
            this.pendingChunks.push({
                id: chunkInfo.id,
                buffer: arrayBuffer
            });

            // Process if not currently appending
            if (!this.isAppending) {
                this.processPendingChunks();
            }

            // Start playback after first chunk
            if (this.chunks.length === 1 && this.video.paused) {
                this.startPlayback();
            }

            // Update progress
            this.updateProgress();
        }

        async processPendingChunks() {
            if (this.isAppending || this.pendingChunks.length === 0) return;
            if (!this.sourceBuffer || this.sourceBuffer.updating) return;

            const chunk = this.pendingChunks.shift();
            this.isAppending = true;

            try {
                this.sourceBuffer.appendBuffer(chunk.buffer);
                this.log(`Appended chunk ${chunk.id} to buffer`);
                this.updateChunkIndicator(chunk.id, 'playing');

            } catch (error) {
                this.log(`Error appending chunk ${chunk.id}`, error.message);
                this.updateChunkIndicator(chunk.id, 'error');
                this.isAppending = false;

                // Check if buffer is full
                if (error.name === 'QuotaExceededError') {
                    this.handleBufferFull();
                }
            }
        }

        handleBufferFull() {
            this.log('Buffer full, removing old data');

            if (!this.sourceBuffer || this.sourceBuffer.updating) return;

            try {
                const currentTime = this.video.currentTime;
                const buffered = this.sourceBuffer.buffered;

                if (buffered.length > 0) {
                    const start = buffered.start(0);
                    const removeEnd = Math.max(start, currentTime - 10);

                    if (removeEnd > start) {
                        this.sourceBuffer.remove(start, removeEnd);
                        this.log(`Removed buffer from ${start} to ${removeEnd}`);
                    }
                }
            } catch (error) {
                this.log('Error removing buffer', error.message);
            }
        }

        async base64ToArrayBuffer(base64Data) {
            try {
                // Remove data URL prefix if present
                const base64String = base64Data.includes(',')
                    ? base64Data.split(',')[1]
                    : base64Data;

                // Decode base64
                const binaryString = atob(base64String);
                const bytes = new Uint8Array(binaryString.length);

                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }

                return bytes.buffer;

            } catch (error) {
                this.log('Base64 decode error', error.message);
                return null;
            }
        }

        startPlayback() {
            if (!this.video.paused) return;

            this.video.play()
                .then(() => {
                    this.log('Playback started');
                    this.updateStatus('Playing stream...', 'success');
                })
                .catch(error => {
                    this.log('Playback error', error.message);

                    // Add play button for user interaction
                    if (error.name === 'NotAllowedError') {
                        this.updateStatus('Click the video to start playback', 'info');
                        this.video.addEventListener('click', () => {
                            this.video.play();
                        }, { once: true });
                    }
                });
        }

        updateProgress() {
            const progress = (this.chunks.length / 9) * 100; // Assuming 9 total chunks
            const progressFill = document.getElementById('progressFill');
            if (progressFill) {
                progressFill.style.width = `${Math.min(progress, 100)}%`;
            }
        }

        updateChunkIndicator(chunkId, status) {
            const container = document.getElementById('chunkIndicators');
            if (!container) return;

            // Create indicator if it doesn't exist
            if (!this.chunkIndicators[chunkId]) {
                const indicator = document.createElement('div');
                indicator.className = 'chunk-indicator';
                indicator.textContent = chunkId;
                indicator.id = `chunk-${chunkId}`;
                container.appendChild(indicator);
                this.chunkIndicators[chunkId] = indicator;
            }

            // Update status
            const indicator = this.chunkIndicators[chunkId];
            indicator.className = `chunk-indicator ${status}`;
        }

        completeStream() {
            this.streamComplete = true;

            if (this.mediaSource && this.mediaSource.readyState === 'open') {
                // Process any remaining chunks
                if (this.pendingChunks.length === 0 && !this.isAppending) {
                    try {
                        this.mediaSource.endOfStream();
                        this.log('Stream ended successfully');
                        this.updateStatus('Stream complete!', 'success');
                    } catch (error) {
                        this.log('Error ending stream', error.message);
                    }
                }
            }
        }

        // Fallback method for browsers without proper MediaSource support
        fallbackToBlob() {
            this.log('Using fallback blob playback');
            this.updateStatus('Using fallback playback mode', 'info');

            // Collect all chunks and create a blob
            const processAllChunks = () => {
                if (this.chunks.length === 0) return;

                Promise.all(this.chunks.map(chunk => this.base64ToArrayBuffer(chunk.data)))
                    .then(buffers => {
                        const validBuffers = buffers.filter(b => b !== null);
                        const blob = new Blob(validBuffers, { type: 'video/mp4' });
                        this.video.src = URL.createObjectURL(blob);
                        this.video.play();
                        this.updateStatus('Playing combined video', 'success');
                    })
                    .catch(error => {
                        this.log('Fallback playback error', error.message);
                        this.updateStatus('Playback failed', 'error');
                    });
            };

            // Wait for all chunks or timeout
            if (this.streamComplete) {
                processAllChunks();
            } else {
                setTimeout(processAllChunks, 5000);
            }
        }

        clear() {
            // Clean up resources
            if (this.mediaSource) {
                if (this.sourceBuffer) {
                    try {
                        this.mediaSource.removeSourceBuffer(this.sourceBuffer);
                    } catch (e) {}
                }
                if (this.mediaSource.readyState === 'open') {
                    try {
                        this.mediaSource.endOfStream();
                    } catch (e) {}
                }
            }

            // Reset state
            this.chunks = [];
            this.pendingChunks = [];
            this.currentChunkIndex = 0;
            this.isInitialized = false;
            this.isAppending = false;
            this.streamComplete = false;
            this.mediaSource = null;
            this.sourceBuffer = null;

            // Clear UI
            this.video.src = '';
            document.getElementById('chunkIndicators').innerHTML = '';
            document.getElementById('progressFill').style.width = '0%';
            this.updateStatus('Cleared', 'info');

            this.log('Processor cleared');
        }
    }

    // Global processor instance
    let streamProcessor = null;

    // Simulate streaming chunks (for testing)
    async function simulateStreamingChunks(processor) {
        // This simulates receiving chunks from your server
        // Replace this with your actual streaming logic

        const mockChunks = [
            { id: 0, duration: 1.5, data: 'base64_video_data_here' },
            { id: 1, duration: 1.5, data: 'base64_video_data_here' },
            { id: 2, duration: 1.5, data: 'base64_video_data_here' },
            // ... more chunks
        ];

        for (let i = 0; i < 9; i++) {
            // Simulate network delay
            await new Promise(resolve => setTimeout(resolve, 500));

            // Create mock chunk (you would use real data here)
            const chunk = {
                id: i,
                duration: 1.5,
                data: 'data:video/mp4;base64,AAAAGGZ0eXBNNFYgAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAA...' // Your actual base64 data
            };

            processor.updateStatus(`Receiving chunk ${i + 1}/9...`, 'info');
            await processor.processChunk(chunk);
        }

        // Signal stream complete
        processor.completeStream();
    }

    // Main functions
    async function startStreaming() {
        const video = document.getElementById('avatarVideo');

        if (streamProcessor) {
            streamProcessor.clear();
        }

        streamProcessor = new VideoStreamProcessor(video);

        // Start your actual streaming here
        // For testing, using simulation
        simulateStreamingChunks(streamProcessor);

        // In production, you would replace the simulation with:
        // await fetchAndProcessStream(streamProcessor);
    }

    function clearVideo() {
        if (streamProcessor) {
            streamProcessor.clear();
        }
    }

    function toggleDebug() {
        const debugLog = document.getElementById('debugLog');
        if (debugLog) {
            debugLog.style.display = debugLog.style.display === 'none' ? 'block' : 'none';
        }
    }

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
        console.log('Page loaded, ready for streaming');
    });
</script>
</body>
</html>