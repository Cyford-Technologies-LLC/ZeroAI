<!DOCTYPE html>
<html>
<head>
    <title>ZeroAI Avatar Debug Console - Complete</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #fff;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(90deg, #007cba, #4CAF50);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        .section {
            background: linear-gradient(145deg, #2a2a2a, #3a3a3a);
            padding: 25px;
            margin: 25px 0;
            border-radius: 12px;
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.3);
            border: 1px solid #444;
        }
        .section h2 {
            margin-top: 0;
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
            font-size: 1.5em;
        }
        .option-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .option-group {
            background: linear-gradient(145deg, #333, #404040);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #555;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        .option-group h4 {
            margin: 0 0 15px 0;
            color: #4CAF50;
            font-size: 1.1em;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 5px;
        }
        .controls {
            display: flex;
            gap: 12px;
            margin: 15px 0;
            flex-wrap: wrap;
            align-items: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            flex-wrap: wrap;
        }
        button {
            padding: 12px 24px;
            background: linear-gradient(145deg, #007cba, #0056b3);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 124, 186, 0.3);
        }
        button:hover {
            background: linear-gradient(145deg, #0056b3, #004085);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 124, 186, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        button.danger {
            background: linear-gradient(145deg, #dc3545, #c82333);
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
        }
        button.danger:hover {
            background: linear-gradient(145deg, #c82333, #bd2130);
        }
        button.success {
            background: linear-gradient(145deg, #28a745, #1e7e34);
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
        }
        button.success:hover {
            background: linear-gradient(145deg, #1e7e34, #155724);
        }
        button.generate {
            background: linear-gradient(145deg, #28a745, #20c997);
            font-size: 18px;
            padding: 15px 30px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }
        input, select, textarea {
            background: linear-gradient(145deg, #333, #404040);
            color: #fff;
            border: 1px solid #555;
            padding: 10px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        input:focus, select:focus, textarea:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.3);
        }
        input[type="file"] {
            padding: 6px;
            background: #444;
        }
        input[type="range"] {
            width: 150px;
            accent-color: #4CAF50;
        }
        input[type="number"] {
            width: 80px;
        }
        input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
            accent-color: #4CAF50;
        }
        input[type="radio"] {
            accent-color: #4CAF50;
            margin-right: 5px;
        }
        textarea {
            width: 100%;
            height: 100px;
            resize: vertical;
            font-family: inherit;
        }
        .log-container {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            padding: 20px;
            height: 300px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.4;
        }
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .status-item {
            background: linear-gradient(145deg, #333, #404040);
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #666;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        .status-ok {
            border-left-color: #28a745;
        }
        .status-error {
            border-left-color: #dc3545;
        }
        .status-warning {
            border-left-color: #ffc107;
        }
        video {
            width: 100%;
            max-width: 600px;
            border: 2px solid #555;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .debug-info {
            background: linear-gradient(145deg, #1a1a2e, #2d2d4a);
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            border: 1px solid #444;
        }
        .loading {
            display: none;
            color: #ffc107;
            text-align: center;
            padding: 20px;
            font-size: 16px;
        }
        .loading.show {
            display: block;
        }
        .error {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #dc3545;
            margin: 15px 0;
        }
        .success {
            color: #28a745;
            background: rgba(40, 167, 69, 0.1);
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #28a745;
            margin: 15px 0;
        }
        .image-preview {
            max-width: 200px;
            max-height: 200px;
            border: 2px solid #555;
            margin: 10px 0;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .tabs {
            display: flex;
            background: #333;
            border-radius: 8px 8px 0 0;
            overflow: hidden;
            margin-top: 20px;
        }
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            background: #444;
            border-right: 1px solid #555;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        .tab:hover {
            background: #555;
        }
        .tab.active {
            background: linear-gradient(145deg, #007cba, #0056b3);
            color: white;
        }
        .tab-content {
            display: none;
            background: linear-gradient(145deg, #333, #404040);
            padding: 25px;
            border-radius: 0 0 8px 8px;
            border: 1px solid #555;
            border-top: none;
        }
        .tab-content.active {
            display: block;
        }
        label {
            display: inline-block;
            min-width: 130px;
            color: #ccc;
            font-weight: 500;
        }
        .range-display {
            color: #4CAF50;
            font-weight: bold;
            margin-left: 12px;
            min-width: 40px;
            display: inline-block;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.3s ease;
        }
        .image-upload-zone {
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 10px 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .image-upload-zone:hover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.05);
        }
        .image-upload-zone.dragover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }
        .peer-selector {
            background: #333;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
        }
        .peer-option {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .peer-option:hover {
            background: #444;
        }
        .peer-option.selected {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 6px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        .notification.show {
            transform: translateX(0);
        }
        .notification.success {
            background: linear-gradient(145deg, #28a745, #20c997);
        }
        .notification.error {
            background: linear-gradient(145deg, #dc3545, #c82333);
        }
        .notification.info {
            background: linear-gradient(145deg, #007cba, #0056b3);
        }
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            .option-grid {
                grid-template-columns: 1fr;
            }
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            .tabs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ZeroAI Avatar Debug Console</h1>
            <p>Complete Avatar Generation System with Full Parameter Control</p>
        </div>

        <div class="section">
            <h2>Avatar Generation Center</h2>

            <!-- Mode Selection -->
            <div class="control-group">
                <label><strong>Generation Mode:</strong></label>
                <input type="radio" id="mode-simple" name="mode" value="simple" checked>
                <label for="mode-simple" style="min-width: auto; margin-right: 20px;">Simple Avatar</label>
                <input type="radio" id="mode-sadtalker" name="mode" value="sadtalker">
                <label for="mode-sadtalker" style="min-width: auto;">SadTalker (Realistic)</label>
            </div>

            <!-- Stream Mode -->
            <div class="control-group">
                <label for="streamMode"><strong>Stream Mode:</strong></label>
                <select id="streamMode">
                    <option value="complete">Complete (Full video)</option>
                    <option value="chunked">Chunked Streaming</option>
                    <option value="realtime">Realtime Streaming</option>
                </select>
            </div>

            <!-- Prompt -->
            <div style="margin: 20px 0;">
                <label for="prompt"><strong>Prompt:</strong></label>
                <textarea id="prompt" placeholder="Enter your prompt here...">Hello! This is a comprehensive test of the avatar system with all available options enabled.</textarea>
            </div>

            <!-- Tabbed Options -->
            <div class="tabs">
                <div class="tab active" onclick="switchTab('tts')">TTS Options</div>
                <div class="tab" onclick="switchTab('image')">Image Options</div>
                <div class="tab" onclick="switchTab('video')">Video Options</div>
                <div class="tab" onclick="switchTab('sadtalker')">SadTalker Options</div>
                <div class="tab" onclick="switchTab('advanced')">Advanced Options</div>
                <div class="tab" onclick="switchTab('peer')">Peer Selection</div>
            </div>

            <!-- TTS Options Tab -->
            <div id="tts-tab" class="tab-content active">
                <div class="option-grid">
                    <div class="option-group">
                        <h4>TTS Engine & Voice</h4>
                        <div class="control-group">
                            <label for="ttsEngine">Engine:</label>
                            <select id="ttsEngine" onchange="updateTTSOptions()">
                                <option value="espeak">eSpeak (Free)</option>
                                <option value="edge">Microsoft Edge TTS</option>
                                <option value="elevenlabs">ElevenLabs (Premium)</option>
                                <option value="openai">OpenAI TTS</option>
                                <option value="coqui">Coqui TTS</option>
                            </select>
                        </div>
                        <div class="control-group" id="voiceGroup">
                            <label for="ttsVoice">Voice:</label>
                            <select id="ttsVoice"></select>
                        </div>
                        <div class="control-group">
                            <label for="ttsLanguage">Language:</label>
                            <select id="ttsLanguage">
                                <option value="en-US">English (US)</option>
                                <option value="en-GB">English (UK)</option>
                                <option value="es-ES">Spanish</option>
                                <option value="fr-FR">French</option>
                                <option value="de-DE">German</option>
                                <option value="it-IT">Italian</option>
                                <option value="pt-BR">Portuguese (Brazil)</option>
                                <option value="ja-JP">Japanese</option>
                                <option value="ko-KR">Korean</option>
                                <option value="zh-CN">Chinese (Simplified)</option>
                            </select>
                        </div>
                    </div>

                    <div class="option-group">
                        <h4>Voice Parameters</h4>
                        <div class="control-group">
                            <label for="ttsSpeed">Speed:</label>
                            <input type="range" id="ttsSpeed" min="50" max="400" value="160" oninput="updateRangeDisplay('speed', this.value)">
                            <span id="speedDisplay" class="range-display">160</span>
                        </div>
                        <div class="control-group">
                            <label for="ttsPitch">Pitch:</label>
                            <input type="range" id="ttsPitch" min="-50" max="50" value="0" oninput="updateRangeDisplay('pitch', this.value)">
                            <span id="pitchDisplay" class="range-display">0</span>
                        </div>
                        <div class="control-group">
                            <label for="ttsEmotion">Emotion:</label>
                            <select id="ttsEmotion">
                                <option value="neutral">Neutral</option>
                                <option value="happy">Happy</option>
                                <option value="sad">Sad</option>
                                <option value="angry">Angry</option>
                                <option value="excited">Excited</option>
                                <option value="calm">Calm</option>
                                <option value="whisper">Whisper</option>
                            </select>
                        </div>
                    </div>

                    <div class="option-group">
                        <h4>Audio Format</h4>
                        <div class="control-group">
                            <label for="sampleRate">Sample Rate:</label>
                            <select id="sampleRate">
                                <option value="16000">16kHz</option>
                                <option value="22050" selected>22kHz</option>
                                <option value="44100">44kHz</option>
                                <option value="48000">48kHz</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="audioFormat">Format:</label>
                            <select id="audioFormat">
                                <option value="wav" selected>WAV</option>
                                <option value="mp3">MP3</option>
                                <option value="ogg">OGG</option>
                                <option value="flac">FLAC</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Image Options Tab -->
            <div id="image-tab" class="tab-content">
                <div class="option-grid">
                    <div class="option-group">
                        <h4>Image Source</h4>
                        <div class="control-group">
                            <input type="radio" id="imageDefault" name="imageSource" value="default" checked onchange="toggleImageSource()">
                            <label for="imageDefault" style="min-width: auto;">Use Default Face</label>
                        </div>
                        <div class="control-group">
                            <input type="radio" id="imageUpload" name="imageSource" value="upload" onchange="toggleImageSource()">
                            <label for="imageUpload" style="min-width: auto;">Upload Image</label>
                        </div>
                        <div class="control-group">
                            <input type="radio" id="imageUrl" name="imageSource" value="url" onchange="toggleImageSource()">
                            <label for="imageUrl" style="min-width: auto;">Image URL</label>
                        </div>

                        <div id="uploadSection" style="display: none; margin-top: 15px;">
                            <div class="image-upload-zone" onclick="document.getElementById('imageFile').click();">
                                <input type="file" id="imageFile" accept="image/*" onchange="handleImageUpload(event)" style="display: none;">
                                <p>Click to upload or drag & drop image</p>
                                <p style="font-size: 12px; color: #999;">Supports: JPEG, PNG, GIF, WebP (max 10MB)</p>
                            </div>
                        </div>

                        <div id="urlSection" style="display: none; margin-top: 15px;">
                            <input type="url" id="imageUrlInput" placeholder="https://example.com/image.jpg" style="width: 100%; margin-bottom: 10px;">
                            <button onclick="previewImageUrl()" class="success">Preview URL</button>
                        </div>

                        <div id="imagePreview" style="margin-top: 15px;">
                            <div style="color: #4CAF50; font-size: 12px;">Using default avatar face</div>
                        </div>
                    </div>

                    <div class="option-group">
                        <h4>Image Processing</h4>
                        <div class="control-group">
                            <label for="preprocess">Preprocessing:</label>
                            <select id="preprocess">
                                <option value="crop">Crop</option>
                                <option value="resize">Resize</option>
                                <option value="none">None</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="resolution">Resolution:</label>
                            <select id="resolution">
                                <option value="256">256x256</option>
                                <option value="512" selected>512x512</option>
                                <option value="1024">1024x1024</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="still">
                            <label for="still" style="min-width: auto;">Still Image (no motion source)</label>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="autoResize" checked>
                            <label for="autoResize" style="min-width: auto;">Auto-resize large images</label>
                        </div>
                    </div>

                    <div class="option-group">
                        <h4>Face Detection</h4>
                        <div class="control-group">
                            <input type="checkbox" id="faceDetection" checked>
                            <label for="faceDetection" style="min-width: auto;">Enable face detection</label>
                        </div>
                        <div class="control-group">
                            <label for="faceConfidence">Min confidence:</label>
                            <input type="range" id="faceConfidence" min="0.1" max="1.0" step="0.1" value="0.5" oninput="updateRangeDisplay('confidence', this.value)">
                            <span id="confidenceDisplay" class="range-display">0.5</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Video Options Tab -->
            <div id="video-tab" class="tab-content">
                <div class="option-grid">
                    <div class="option-group">
                        <h4>Video Codec & Quality</h4>
                        <div class="control-group">
                            <label for="codec">Codec:</label>
                            <select id="codec">
                                <option value="h264_high">H264 High Quality</option>
                                <option value="h264_medium">H264 Medium</option>
                                <option value="h264_fast" selected>H264 Fast</option>
                                <option value="h265_high">H265 High Quality</option>
                                <option value="h265_medium">H265 Medium</option>
                                <option value="webm_high">WebM High Quality</option>
                                <option value="webm_fast">WebM Fast</option>
                                <option value="av1_high">AV1 High Quality</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="quality">Quality:</label>
                            <select id="quality">
                                <option value="ultra">Ultra (Slow)</option>
                                <option value="high">High</option>
                                <option value="medium" selected>Medium</option>
                                <option value="fast">Fast</option>
                                <option value="ultrafast">Ultra Fast</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="fps">Frame Rate:</label>
                            <select id="fps">
                                <option value="12">12 FPS</option>
                                <option value="15">15 FPS</option>
                                <option value="20">20 FPS</option>
                                <option value="24">24 FPS</option>
                                <option value="25" selected>25 FPS</option>
                                <option value="30">30 FPS</option>
                                <option value="60">60 FPS</option>
                            </select>
                        </div>
                    </div>

                    <div class="option-group">
                        <h4>Streaming Options</h4>
                        <div class="control-group">
                            <label for="chunkDuration">Chunk Duration:</label>
                            <input type="number" id="chunkDuration" min="1" max="10" value="3" step="0.5">
                            <span>seconds</span>
                        </div>
                        <div class="control-group">
                            <label for="bufferSize">Buffer Size:</label>
                            <input type="number" id="bufferSize" min="1" max="20" value="5">
                            <span>frames</span>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="lowLatency">
                            <label for="lowLatency" style="min-width: auto;">Low Latency Mode</label>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="adaptiveQuality" checked>
                            <label for="adaptiveQuality" style="min-width: auto;">Adaptive Quality</label>
                        </div>
                    </div>

                    <div class="option-group">
                        <h4>Advanced Video</h4>
                        <div class="control-group">
                            <label for="bitrate">Bitrate (kbps):</label>
                            <input type="number" id="bitrate" min="500" max="10000" value="2000" step="100">
                        </div>
                        <div class="control-group">
                            <label for="keyframeInterval">Keyframe Interval:</label>
                            <input type="number" id="keyframeInterval" min="1" max="10" value="2">
                            <span>seconds</span>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="hardwareAccel">
                            <label for="hardwareAccel" style="min-width: auto;">Hardware Acceleration</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- SadTalker Options Tab -->
            <div id="sadtalker-tab" class="tab-content">
                <div class="option-grid">
                    <div class="option-group">
                        <h4>Generation Settings</h4>
                        <div class="control-group">
                            <label for="timeout">Timeout:</label>
                            <input type="number" id="timeout" min="60" max="3600" value="1200">
                            <span>seconds</span>
                        </div>
                        <div class="control-group">
                            <label for="enhancer">Enhancer:</label>
                            <select id="enhancer">
                                <option value="">None</option>
                                <option value="gfpgan">GFPGAN</option>
                                <option value="restoreformer">RestoreFormer</option>
                                <option value="codeformer">CodeFormer</option>
                                <option value="real-esrgan">Real-ESRGAN</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="expressionScale">Expression Scale:</label>
                            <input type="range" id="expressionScale" min="0.5" max="2.0" step="0.1" value="1.0" oninput="updateRangeDisplay('expression', this.value)">
                            <span id="expressionDisplay" class="range-display">1.0</span>
                        </div>
                    </div>

                    <div class="option-group">
                        <h4>Chunking Options</h4>
                        <div class="control-group">
                            <input type="checkbox" id="splitChunks">
                            <label for="splitChunks" style="min-width: auto;">Split into Chunks</label>
                        </div>
                        <div class="control-group">
                            <label for="chunkLength">Chunk Length:</label>
                            <input type="number" id="chunkLength" min="5" max="30" value="10">
                            <span>seconds</span>
                        </div>
                        <div class="control-group">
                            <label for="overlapDuration">Overlap Duration:</label>
                            <input type="number" id="overlapDuration" min="0" max="5" value="1" step="0.5">
                            <span>seconds</span>
                        </div>
                    </div>

                    <div class="option-group">
                        <h4>Advanced SadTalker</h4>
                        <div class="control-group">
                            <input type="checkbox" id="use3dWarping" checked>
                            <label for="use3dWarping" style="min-width: auto;">3D Face Warping</label>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="useEyeBlink" checked>
                            <label for="useEyeBlink" style="min-width: auto;">Eye Blinking</label>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="useHeadPose" checked>
                            <label for="useHeadPose" style="min-width: auto;">Head Pose Animation</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Advanced Options Tab -->
            <div id="advanced-tab" class="tab-content">
                <div class="option-grid">
                    <div class="option-group">
                        <h4>Performance</h4>
                        <div class="control-group">
                            <label for="maxDuration">Max Duration:</label>
                            <input type="number" id="maxDuration" min="10" max="600" value="300">
                            <span>seconds</span>
                        </div>
                        <div class="control-group">
                            <label for="maxConcurrent">Max Concurrent:</label>
                            <input type="number" id="maxConcurrent" min="1" max="10" value="3">
                        </div>
                        <div class="control-group">
                            <label for="memoryLimit">Memory Limit:</label>
                            <input type="number" id="memoryLimit" min="1" max="16" value="8">
                            <span>GB</span>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="enableWebsocket">
                            <label for="enableWebsocket" style="min-width: auto;">Enable WebSocket</label>
                        </div>
                    </div>

                    <div class="option-group">
                        <h4>Debug Options</h4>
                        <div class="control-group">
                            <input type="checkbox" id="debugMode" checked>
                            <label for="debugMode" style="min-width: auto;">Debug Mode</label>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="verboseLogging">
                            <label for="verboseLogging" style="min-width: auto;">Verbose Logging</label>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="saveIntermediates">
                            <label for="saveIntermediates" style="min-width: auto;">Save Intermediate Files</label>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="profilePerformance">
                            <label for="profilePerformance" style="min-width: auto;">Performance Profiling</label>
                        </div>
                    </div>

                    <div class="option-group">
                        <h4>Experimental Features</h4>
                        <div class="control-group">
                            <input type="checkbox" id="betaFeatures">
                            <label for="betaFeatures" style="min-width: auto;">Enable Beta Features</label>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="mlAcceleration">
                            <label for="mlAcceleration" style="min-width: auto;">ML Acceleration</label>
                        </div>
                        <div class="control-group">
                            <label for="workerThreads">Worker Threads:</label>
                            <input type="number" id="workerThreads" min="1" max="16" value="4">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Peer Selection Tab -->
            <div id="peer-tab" class="tab-content">
                <div class="option-grid">
                    <div class="option-group">
                        <h4>Current Server</h4>
                        <div id="currentPeerDisplay" class="peer-selector">
                            <div class="loading">Loading server information...</div>
                        </div>
                        <button onclick="refreshPeerInfo()" class="success">Refresh Server Info</button>
                    </div>

                    <div class="option-group">
                        <h4>Available Servers</h4>
                        <div id="availablePeers" class="peer-selector">
                            <div class="loading">Loading available servers...</div>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="autoSelectBest" checked>
                            <label for="autoSelectBest" style="min-width: auto;">Auto-select best server</label>
                        </div>
                    </div>

                    <div class="option-group">
                        <h4>Server Preferences</h4>
                        <div class="control-group">
                            <label for="preferredGpuMemory">Min GPU Memory:</label>
                            <input type="number" id="preferredGpuMemory" min="0" max="24" value="4">
                            <span>GB</span>
                        </div>
                        <div class="control-group">
                            <label for="preferredLatency">Max Latency:</label>
                            <input type="number" id="preferredLatency" min="10" max="1000" value="100">
                            <span>ms</span>
                        </div>
                        <div class="control-group">
                            <input type="checkbox" id="fallbackToLocal" checked>
                            <label for="fallbackToLocal" style="min-width: auto;">Fallback to local if peers fail</label>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="controls" style="margin-top: 30px; justify-content: center;">
                <button onclick="generateAvatar()" class="generate">Generate Avatar</button>
                <button onclick="testMP4()" class="success">Test MP4 Pipeline</button>
                <button onclick="testConnection()" class="success">Test Connection</button>
                <button onclick="getEngines()">Get TTS Engines</button>
                <button onclick="getStatus()">Get Status</button>
                <button onclick="getLogs()">Get Logs</button>
                <button onclick="clearLogs()" class="danger">Clear Logs</button>
            </div>

            <div class="loading" id="loading">
                <p>Generating avatar... This may take a few minutes.</p>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div id="progressText">Initializing...</div>
            </div>

            <div id="result" style="display: none;">
                <h3>Generated Avatar:</h3>
                <video id="avatarVideo" controls>
                    Your browser does not support the video tag.
                </video>
                <div class="debug-info" id="videoInfo"></div>
                <div class="controls">
                    <button onclick="downloadVideo()" class="success">Download Video</button>
                    <button onclick="shareVideo()" class="success">Share Video</button>
                </div>
            </div>

            <div id="error" class="error" style="display: none;"></div>
        </div>

        <!-- Server Connection -->
        <div class="section">
            <h2>Server Connection</h2>
            <div class="controls">
                <button onclick="getServerInfo()">Get Server Info</button>
                <button onclick="pingAllServers()">Ping All Servers</button>
                <button onclick="benchmarkServers()" class="success">Benchmark Servers</button>
            </div>
            <div class="status-grid" id="serverInfo">
                <div class="status-item">Click "Get Server Info" to see which avatar server is being used...</div>
            </div>
        </div>

        <!-- System Status -->
        <div class="section">
            <h2>System Status</h2>
            <div class="controls">
                <button onclick="refreshStatus()">Refresh Status</button>
                <button onclick="getDetailedStatus()">Detailed Status</button>
                <button onclick="exportStatus()" class="success">Export Status</button>
            </div>
            <div class="status-grid" id="statusGrid">
                <div class="status-item">Loading status...</div>
            </div>
        </div>

        <!-- Debug Logs -->
        <div class="section">
            <h2>Debug Logs</h2>
            <div class="controls">
                <button onclick="refreshLogs()">Refresh Logs</button>
                <button onclick="clearDebugLogs()" class="danger">Clear Debug Logs</button>
                <button onclick="downloadLogs()">Download Logs</button>
                <button onclick="copyLogsToClipboard()">Copy to Clipboard</button>
                <button onclick="filterLogs()">Filter Logs</button>
            </div>
            <div class="controls">
                <label for="logLevel">Log Level:</label>
                <select id="logLevel" onchange="filterLogsByLevel()">
                    <option value="all">All</option>
                    <option value="error">Error</option>
                    <option value="warning">Warning</option>
                    <option value="info" selected>Info</option>
                    <option value="debug">Debug</option>
                </select>
                <input type="text" id="logSearch" placeholder="Search logs..." oninput="searchLogs()" style="width: 200px;">
            </div>
            <div class="log-container" id="logContainer">
                Click "Refresh Logs" to load debug information...
            </div>
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notification" class="notification"></div>

    <script>
        let debugMode = true;
        let currentMode = 'simple';
        let currentImageData = null;
        let selectedPeer = null;
        let generationInProgress = false;

        // TTS Engine configurations
        const TTS_ENGINES = {
            espeak: {
                name: 'eSpeak (Free)',
                voices: [
                    { value: 'en', label: 'English (Default)' },
                    { value: 'en+f3', label: 'English Female 3' },
                    { value: 'en+f4', label: 'English Female 4' },
                    { value: 'en+m3', label: 'English Male 3' },
                    { value: 'en+m4', label: 'English Male 4' },
                    { value: 'en+f5', label: 'English Female 5' },
                    { value: 'en+m5', label: 'English Male 5' }
                ],
                speedRange: [80, 400],
                pitchRange: [0, 99]
            },
            edge: {
                name: 'Microsoft Edge TTS',
                voices: [
                    { value: 'en-US-AriaNeural', label: 'Aria (Female)' },
                    { value: 'en-US-JennyNeural', label: 'Jenny (Female)' },
                    { value: 'en-US-GuyNeural', label: 'Guy (Male)' },
                    { value: 'en-US-DavisNeural', label: 'Davis (Male)' },
                    { value: 'en-US-JaneNeural', label: 'Jane (Female)' },
                    { value: 'en-US-JasonNeural', label: 'Jason (Male)' },
                    { value: 'en-US-SaraNeural', label: 'Sara (Female)' },
                    { value: 'en-US-TonyNeural', label: 'Tony (Male)' }
                ],
                speedRange: [50, 300],
                pitchRange: [-50, 50]
            },
            elevenlabs: {
                name: 'ElevenLabs (Premium)',
                voices: [
                    { value: '21m00Tcm4TlvDq8ikWAM', label: 'Rachel (Female)' },
                    { value: 'AZnzlk1XvdvUeBnXmlld', label: 'Domi (Female)' },
                    { value: 'EXAVITQu4vr4xnSDxMaL', label: 'Bella (Female)' },
                    { value: 'ErXwobaYiN019PkySvjV', label: 'Antoni (Male)' },
                    { value: 'MF3mGyEYCl7XYWbV9V6O', label: 'Elli (Female)' },
                    { value: 'TxGEqnHWrfWFTfGW9XjX', label: 'Josh (Male)' },
                    { value: 'VR6AewLTigWG4xSOukaG', label: 'Arnold (Male)' },
                    { value: 'pNInz6obpgDQGcFmaJgB', label: 'Adam (Male)' }
                ],
                speedRange: [50, 200],
                pitchRange: [-100, 100]
            },
            openai: {
                name: 'OpenAI TTS',
                voices: [
                    { value: 'alloy', label: 'Alloy (Neutral)' },
                    { value: 'echo', label: 'Echo (Male)' },
                    { value: 'fable', label: 'Fable (British Male)' },
                    { value: 'onyx', label: 'Onyx (Male)' },
                    { value: 'nova', label: 'Nova (Female)' },
                    { value: 'shimmer', label: 'Shimmer (Female)' }
                ],
                speedRange: [25, 400],
                pitchRange: [0, 0]
            },
            coqui: {
                name: 'Coqui TTS',
                voices: [
                    { value: 'female', label: 'Female (Default)' },
                    { value: 'male', label: 'Male (Default)' },
                    { value: 'female_emotional', label: 'Female (Emotional)' },
                    { value: 'male_emotional', label: 'Male (Emotional)' }
                ],
                speedRange: [50, 200],
                pitchRange: [-50, 50]
            }
        };

        // Utility Functions
        function debugLog(message, data = null) {
            const timestamp = new Date().toISOString();
            console.log(`[${timestamp}] ${message}`, data || '');

            if (debugMode) {
                const logEntry = `${timestamp}: ${message}${data ? ' - ' + JSON.stringify(data, null, 2) : ''}`;
                appendToLog('logContainer', logEntry);
            }
        }

        function appendToLog(containerId, message) {
            const container = document.getElementById(containerId);
            if (container) {
                container.innerHTML += message + '\n';
                container.scrollTop = container.scrollHeight;
            }
        }

        function showNotification(message, type = 'info', duration = 3000) {
            const notification = document.getElementById('notification');
            if (notification) {
                notification.textContent = message;
                notification.className = `notification ${type} show`;

                setTimeout(() => {
                    notification.classList.remove('show');
                }, duration);
            }
        }

        function updateProgress(percent, text = '') {
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');

            if (progressFill) progressFill.style.width = percent + '%';
            if (progressText && text) progressText.textContent = text;
        }

        // Tab Management
        function switchTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });

            // Add active class to selected tab and content
            const tabContent = document.getElementById(tabName + '-tab');
            if (tabContent) {
                tabContent.classList.add('active');
            }

            // Find and activate the clicked tab
            const clickedTab = event.target;
            if (clickedTab) {
                clickedTab.classList.add('active');
            }

            debugLog('Switched to tab', { tab: tabName });
        }

        // Range Display Updates
        function updateRangeDisplay(type, value) {
            const display = document.getElementById(type + 'Display');
            if (display) {
                display.textContent = value;
            }
        }

        // TTS Engine Management
        function updateTTSOptions() {
            const engine = document.getElementById('ttsEngine').value;
            const voiceSelect = document.getElementById('ttsVoice');
            const speedRange = document.getElementById('ttsSpeed');
            const pitchRange = document.getElementById('ttsPitch');

            if (TTS_ENGINES[engine] && voiceSelect && speedRange && pitchRange) {
                const config = TTS_ENGINES[engine];

                voiceSelect.innerHTML = config.voices
                    .map(v => `<option value="${v.value}">${v.label}</option>`)
                    .join('');

                speedRange.min = config.speedRange[0];
                speedRange.max = config.speedRange[1];
                speedRange.value = Math.floor((config.speedRange[0] + config.speedRange[1]) / 2);
                updateRangeDisplay('speed', speedRange.value);

                pitchRange.min = config.pitchRange[0];
                pitchRange.max = config.pitchRange[1];
                pitchRange.value = 0;
                updateRangeDisplay('pitch', pitchRange.value);

                debugLog('TTS engine updated', { engine, voiceCount: config.voices.length });
            }
        }

        // Image Upload Management
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) {
                currentImageData = null;
                const preview = document.getElementById('imagePreview');
                if (preview) preview.innerHTML = '';
                return;
            }

            const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'];
            if (!allowedTypes.includes(file.type)) {
                showNotification('Unsupported file type. Please use JPEG, PNG, GIF, or WebP images.', 'error');
                event.target.value = '';
                return;
            }

            const maxSize = 10 * 1024 * 1024;
            if (file.size > maxSize) {
                showNotification(`File too large. Maximum size is ${Math.round(maxSize / 1024 / 1024)}MB. Your file is ${Math.round(file.size / 1024 / 1024)}MB.`, 'error');
                event.target.value = '';
                return;
            }

            const preview = document.getElementById('imagePreview');
            if (preview) {
                preview.innerHTML = '<div class="loading">Processing image...</div>';
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const imageData = e.target.result;

                if (!imageData.startsWith('data:image/')) {
                    showNotification('Invalid image file', 'error');
                    event.target.value = '';
                    if (preview) preview.innerHTML = '';
                    return;
                }

                const img = new Image();
                img.onload = function() {
                    const minWidth = 64, minHeight = 64;
                    const maxWidth = 2048, maxHeight = 2048;

                    if (img.width < minWidth || img.height < minHeight) {
                        showNotification(`Image too small. Minimum size is ${minWidth}x${minHeight}px. Your image is ${img.width}x${img.height}px.`, 'error');
                        event.target.value = '';
                        if (preview) preview.innerHTML = '';
                        return;
                    }

                    if (img.width > maxWidth || img.height > maxHeight) {
                        const autoResize = document.getElementById('autoResize');
                        if (!autoResize || (!autoResize.checked && !confirm(`Image is large (${img.width}x${img.height}px). Maximum recommended size is ${maxWidth}x${maxHeight}px. Continue anyway?`))) {
                            event.target.value = '';
                            if (preview) preview.innerHTML = '';
                            return;
                        }
                    }

                    currentImageData = imageData;
                    displayImagePreview(imageData, {
                        width: img.width,
                        height: img.height,
                        size: file.size,
                        type: file.type,
                        name: file.name
                    });

                    showNotification('Image uploaded successfully', 'success');
                    debugLog('Image uploaded successfully', {
                        filename: file.name,
                        size: file.size,
                        type: file.type,
                        dimensions: `${img.width}x${img.height}`
                    });
                };

                img.onerror = function() {
                    showNotification('Failed to load image. Please try a different file.', 'error');
                    event.target.value = '';
                    if (preview) preview.innerHTML = '';
                };

                img.src = imageData;
            };

            reader.onerror = function() {
                showNotification('Failed to read file. Please try again.', 'error');
                event.target.value = '';
                const preview = document.getElementById('imagePreview');
                if (preview) preview.innerHTML = '';
            };

            reader.readAsDataURL(file);
        }

        function previewImageUrl() {
            const urlInput = document.getElementById('imageUrlInput');
            const url = urlInput ? urlInput.value.trim() : '';

            if (!url) {
                showNotification('Please enter an image URL', 'error');
                return;
            }

            try {
                new URL(url);
            } catch (e) {
                showNotification('Invalid URL format', 'error');
                return;
            }

            const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
            const hasImageExtension = imageExtensions.some(ext =>
                url.toLowerCase().includes(ext)
            );

            if (!hasImageExtension && !url.includes('image') && !url.includes('photo')) {
                if (!confirm('URL doesn\'t appear to be an image. Continue anyway?')) {
                    return;
                }
            }

            const preview = document.getElementById('imagePreview');
            if (preview) {
                preview.innerHTML = '<div class="loading">Loading image from URL...</div>';
            }

            const img = new Image();
            img.onload = function() {
                currentImageData = url;
                displayImagePreview(url, {
                    width: img.width,
                    height: img.height,
                    type: 'url',
                    url: url
                });

                showNotification('Image URL loaded successfully', 'success');
                debugLog('Image URL loaded successfully', {
                    url: url,
                    dimensions: `${img.width}x${img.height}`
                });
            };

            img.onerror = function() {
                showNotification('Failed to load image from URL. Please check the URL and try again.', 'error');
                if (preview) preview.innerHTML = '';
                currentImageData = null;
            };

            img.crossOrigin = 'anonymous';
            img.src = url;
        }

        function displayImagePreview(src, metadata = {}) {
            const preview = document.getElementById('imagePreview');
            if (!preview) return;

            let metaInfo = '';
            if (metadata.width && metadata.height) {
                metaInfo += `<div><strong>Dimensions:</strong> ${metadata.width}x${metadata.height}px</div>`;
            }
            if (metadata.size) {
                metaInfo += `<div><strong>Size:</strong> ${Math.round(metadata.size / 1024)}KB</div>`;
            }
            if (metadata.type && metadata.type !== 'url') {
                metaInfo += `<div><strong>Type:</strong> ${metadata.type}</div>`;
            }
            if (metadata.name) {
                metaInfo += `<div><strong>File:</strong> ${metadata.name}</div>`;
            }
            if (metadata.url) {
                metaInfo += `<div><strong>URL:</strong> <a href="${metadata.url}" target="_blank" style="color: #4CAF50;">View Original</a></div>`;
            }

            preview.innerHTML = `
                <img src="${src}" class="image-preview" alt="Preview">
                <div style="font-size: 12px; color: #ccc; margin-top: 5px;">
                    ${metaInfo}
                    <button onclick="clearImagePreview()" style="margin-top: 5px; padding: 3px 8px; font-size: 11px;" class="danger">Clear Image</button>
                </div>
            `;
        }

        function clearImagePreview() {
            currentImageData = null;
            const preview = document.getElementById('imagePreview');
            const imageFile = document.getElementById('imageFile');
            const imageUrlInput = document.getElementById('imageUrlInput');
            const imageDefault = document.getElementById('imageDefault');

            if (preview) preview.innerHTML = '';
            if (imageFile) imageFile.value = '';
            if (imageUrlInput) imageUrlInput.value = '';
            if (imageDefault) imageDefault.checked = true;

            toggleImageSource();

            showNotification('Image selection cleared', 'info');
            debugLog('Image selection cleared');
        }

        function toggleImageSource() {
            const uploadSection = document.getElementById('uploadSection');
            const urlSection = document.getElementById('urlSection');
            const previewSection = document.getElementById('imagePreview');
            const sourceRadios = document.querySelectorAll('input[name="imageSource"]');

            let source = 'default';
            for (let radio of sourceRadios) {
                if (radio.checked) {
                    source = radio.value;
                    break;
                }
            }

            if (uploadSection) uploadSection.style.display = 'none';
            if (urlSection) urlSection.style.display = 'none';

            const imageFile = document.getElementById('imageFile');
            const imageUrlInput = document.getElementById('imageUrlInput');

            if (source !== 'upload' && imageFile) {
                imageFile.value = '';
            }
            if (source !== 'url' && imageUrlInput) {
                imageUrlInput.value = '';
            }

            switch (source) {
                case 'upload':
                    if (uploadSection) uploadSection.style.display = 'block';
                    break;
                case 'url':
                    if (urlSection) urlSection.style.display = 'block';
                    break;
                case 'default':
                    currentImageData = null;
                    if (previewSection) {
                        previewSection.innerHTML = '<div style="color: #4CAF50; font-size: 12px;">Using default avatar face</div>';
                    }
                    break;
            }

            if (source === 'default') {
                if (previewSection) {
                    previewSection.innerHTML = '<div style="color: #4CAF50; font-size: 12px;">Using default avatar face</div>';
                }
            } else if (currentImageData && source !== getCurrentImageSource()) {
                clearImagePreview();
            }
        }

        function getCurrentImageSource() {
            if (!currentImageData) return 'default';
            if (currentImageData.startsWith('data:image/')) return 'upload';
            if (currentImageData.startsWith('http')) return 'url';
            return 'file';
        }

        function validateImageForGeneration() {
            const sourceRadios = document.querySelectorAll('input[name="imageSource"]');
            let source = 'default';
            for (let radio of sourceRadios) {
                if (radio.checked) {
                    source = radio.value;
                    break;
                }
            }

            if (source === 'default') {
                return { valid: true, data: null };
            }

            if (!currentImageData) {
                return {
                    valid: false,
                    error: `No image selected for ${source} mode. Please select an image or switch to default mode.`
                };
            }

            const modeRadios = document.querySelectorAll('input[name="mode"]');
            let mode = 'simple';
            for (let radio of modeRadios) {
                if (radio.checked) {
                    mode = radio.value;
                    break;
                }
            }

            if (mode === 'sadtalker' && source === 'default') {
                return {
                    valid: false,
                    error: 'SadTalker mode requires a custom image. Please upload an image or provide a URL.'
                };
            }

            return { valid: true, data: currentImageData };
        }

        // Mode change handler
        document.addEventListener('DOMContentLoaded', function() {
            const modeRadios = document.querySelectorAll('input[name="mode"]');
            modeRadios.forEach(radio => {
                radio.addEventListener('change', function() {
                    currentMode = this.value;
                    debugLog('Mode changed', { mode: currentMode });

                    // Update UI based on mode
                    if (currentMode === 'sadtalker') {
                        showNotification('SadTalker mode requires a custom image for best results', 'info');
                    }
                });
            });
        });

        // Peer Management
        async function refreshPeerInfo() {
            debugLog('Refreshing peer information');
            try {
                await getServerInfo();
                await loadAvailablePeers();
                showNotification('Peer information refreshed', 'success');
            } catch (error) {
                debugLog('Failed to refresh peer info', { error: error.message });
                showNotification('Failed to refresh peer information', 'error');
            }
        }

        async function loadAvailablePeers() {
            try {
                const response = await fetch('/web/api/avatar_dual.php?action=server_info');
                const result = await response.json();

                if (result.available_peers) {
                    displayAvailablePeers(result.available_peers);
                }
            } catch (error) {
                debugLog('Failed to load available peers', { error: error.message });
            }
        }

        function displayAvailablePeers(peers) {
            const container = document.getElementById('availablePeers');
            if (!container) return;

            if (!peers || peers.length === 0) {
                container.innerHTML = '<div class="peer-option">No peers available</div>';
                return;
            }

            let html = '';
            peers.forEach(peer => {
                const isSelected = selectedPeer === peer.id;
                const statusClass = peer.status === 'online' ? 'status-ok' : 'status-error';

                html += `
                    <div class="peer-option ${isSelected ? 'selected' : ''}" onclick="selectPeer('${peer.id}')">
                        <div style="flex: 1;">
                            <strong>${peer.name}</strong> (${peer.type})<br>
                            <small>
                                Status: <span class="${statusClass}">${peer.status}</span>
                                ${peer.gpu_memory_gb ? ` | GPU: ${peer.gpu_memory_gb}GB` : ''}
                                ${peer.memory_gb ? ` | RAM: ${peer.memory_gb}GB` : ''}
                                ${peer.score ? ` | Score: ${peer.score}` : ''}
                            </small>
                        </div>
                        <div>
                            ${isSelected ? '✓' : ''}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function selectPeer(peerId) {
            selectedPeer = peerId;
            debugLog('Peer selected', { peerId });

            // Update UI
            const peerOptions = document.querySelectorAll('.peer-option');
            peerOptions.forEach(option => {
                option.classList.remove('selected');
            });

            // Find the clicked element and mark it as selected
            const clickedOption = event.target.closest('.peer-option');
            if (clickedOption) {
                clickedOption.classList.add('selected');
            }

            showNotification(`Selected peer: ${peerId}`, 'success');
        }

        // Main Generation Function
        async function generateAvatar() {
            if (generationInProgress) {
                showNotification('Generation already in progress', 'warning');
                return;
            }

            const loading = document.getElementById('loading');
            const result = document.getElementById('result');
            const error = document.getElementById('error');
            const video = document.getElementById('avatarVideo');
            const videoInfo = document.getElementById('videoInfo');

            // Validate image selection
            const imageValidation = validateImageForGeneration();
            if (!imageValidation.valid) {
                if (error) {
                    error.textContent = imageValidation.error;
                    error.style.display = 'block';
                }
                return;
            }

            // Get form values safely
            const getElementValue = (id, defaultValue = '') => {
                const element = document.getElementById(id);
                return element ? element.value : defaultValue;
            };

            const getElementChecked = (id, defaultValue = false) => {
                const element = document.getElementById(id);
                return element ? element.checked : defaultValue;
            };

            const getRadioValue = (name, defaultValue = '') => {
                const radio = document.querySelector(`input[name="${name}"]:checked`);
                return radio ? radio.value : defaultValue;
            };

            // Collect ALL options from the form
            const payload = {
                // Core settings
                prompt: getElementValue('prompt'),
                mode: getRadioValue('mode', 'simple'),
                stream_mode: getElementValue('streamMode'),

                // TTS options
                tts_engine: getElementValue('ttsEngine'),
                tts_voice: getElementValue('ttsVoice'),
                tts_speed: parseInt(getElementValue('ttsSpeed', '160')),
                tts_pitch: parseInt(getElementValue('ttsPitch', '0')),
                tts_language: getElementValue('ttsLanguage'),
                tts_emotion: getElementValue('ttsEmotion'),

                // Audio format
                sample_rate: parseInt(getElementValue('sampleRate', '22050')),
                format: getElementValue('audioFormat'),

                // Image options
                image: imageValidation.data,
                still: getElementChecked('still'),
                preprocess: getElementValue('preprocess'),
                resolution: getElementValue('resolution'),
                face_detection: getElementChecked('faceDetection'),
                face_confidence: parseFloat(getElementValue('faceConfidence', '0.5')),
                auto_resize: getElementChecked('autoResize'),

                // Video options
                codec: getElementValue('codec'),
                quality: getElementValue('quality'),
                fps: parseInt(getElementValue('fps', '25')),
                bitrate: parseInt(getElementValue('bitrate', '2000')),
                keyframe_interval: parseInt(getElementValue('keyframeInterval', '2')),
                hardware_accel: getElementChecked('hardwareAccel'),

                // Streaming options
                chunk_duration: parseFloat(getElementValue('chunkDuration', '3')),
                buffer_size: parseInt(getElementValue('bufferSize', '5')),
                low_latency: getElementChecked('lowLatency'),
                adaptive_quality: getElementChecked('adaptiveQuality'),

                // SadTalker options
                timeout: parseInt(getElementValue('timeout', '1200')),
                enhancer: getElementValue('enhancer') || null,
                split_chunks: getElementChecked('splitChunks'),
                chunk_length: parseInt(getElementValue('chunkLength', '10')),
                overlap_duration: parseFloat(getElementValue('overlapDuration', '1')),
                expression_scale: parseFloat(getElementValue('expressionScale', '1.0')),
                use_3d_warping: getElementChecked('use3dWarping'),
                use_eye_blink: getElementChecked('useEyeBlink'),
                use_head_pose: getElementChecked('useHeadPose'),

                // Advanced options
                max_duration: parseInt(getElementValue('maxDuration', '300')),
                max_concurrent: parseInt(getElementValue('maxConcurrent', '3')),
                memory_limit: parseInt(getElementValue('memoryLimit', '8')),
                enable_websocket: getElementChecked('enableWebsocket'),
                verbose_logging: getElementChecked('verboseLogging'),
                save_intermediates: getElementChecked('saveIntermediates'),
                profile_performance: getElementChecked('profilePerformance'),
                beta_features: getElementChecked('betaFeatures'),
                ml_acceleration: getElementChecked('mlAcceleration'),
                worker_threads: parseInt(getElementValue('workerThreads', '4')),

                // Peer selection
                peer: selectedPeer
            };

            debugLog('Starting avatar generation with complete options', payload);
            generationInProgress = true;

            if (loading) {
                loading.style.display = 'block';
                loading.classList.add('show');
            }
            if (result) result.style.display = 'none';
            if (error) error.style.display = 'none';

            try {
                updateProgress(10, 'Initializing generation...');
                const startTime = Date.now();

                const response = await fetch(`/web/api/avatar_dual.php?action=generate&mode=${payload.mode}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                updateProgress(50, 'Processing avatar...');
                const duration = Date.now() - startTime;

                debugLog('Avatar API response received', {
                    status: response.status,
                    statusText: response.statusText,
                    ok: response.ok,
                    contentType: response.headers.get('content-type'),
                    duration: duration + 'ms'
                });

                if (response.ok) {
                    const contentType = response.headers.get('content-type');
                    updateProgress(80, 'Processing response...');

                    // Handle streaming responses
                    if (contentType && contentType.includes('multipart/x-mixed-replace')) {
                        debugLog('Streaming response detected', { contentType });
                        updateProgress(90, 'Processing stream...');

                        try {
                            await handleStreamingResponse(response, video, videoInfo, payload, duration);
                            if (result) result.style.display = 'block';
                            updateProgress(100, 'Streaming complete!');
                            showNotification('Avatar streaming completed successfully!', 'success');
                        } catch (streamError) {
                            debugLog('Streaming processing failed', { error: streamError.message });
                            throw new Error('Streaming processing failed: ' + streamError.message);
                        }

                    // Handle regular video responses
                    } else if (contentType && contentType.includes('video')) {
                        debugLog('Regular video response detected', { contentType });
                        updateProgress(90, 'Finalizing video...');

                        const blob = await response.blob();
                        const videoUrl = URL.createObjectURL(blob);

                        if (video) video.src = videoUrl;
                        if (result) result.style.display = 'block';

                        if (videoInfo) {
                            videoInfo.innerHTML = `
                                <strong>Generation Complete!</strong><br>
                                Mode: ${response.headers.get('x-avatar-mode') || payload.mode}<br>
                                Engine: ${response.headers.get('x-avatar-engine') || payload.tts_engine}<br>
                                Voice: ${response.headers.get('x-avatar-voice') || payload.tts_voice}<br>
                                Size: ${(blob.size / 1024 / 1024).toFixed(2)} MB<br>
                                Type: ${contentType}<br>
                                Generation Time: ${(duration / 1000).toFixed(1)}s<br>
                                Parameters: ${Object.keys(payload).length} options used
                            `;
                        }

                        updateProgress(100, 'Complete!');

                        if (video) {
                            video.onloadeddata = () => {
                                debugLog('Video loaded successfully', {
                                    duration: video.duration,
                                    videoWidth: video.videoWidth,
                                    videoHeight: video.videoHeight
                                });
                                showNotification('Avatar generated successfully!', 'success');
                            };

                            video.onerror = (e) => {
                                debugLog('Video error', { error: video.error });
                                showNotification('Video playback error', 'error');
                            };
                        }

                    // Handle JSON responses (like WebSocket info)
                    } else if (contentType && contentType.includes('json')) {
                        debugLog('JSON response detected', { contentType });
                        const jsonData = await response.json();

                        if (jsonData.type === 'websocket_info') {
                            debugLog('WebSocket info received', jsonData);
                            showNotification('WebSocket streaming info received - check console', 'info');
                            if (error) {
                                error.innerHTML = `<strong>WebSocket Streaming:</strong><br>
                                    Connect to: ${jsonData.websocket_url}<br>
                                    <small>WebSocket streaming requires additional frontend implementation</small>`;
                                error.style.display = 'block';
                            }
                        } else {
                            debugLog('Unknown JSON response', jsonData);
                            throw new Error('Unexpected JSON response: ' + JSON.stringify(jsonData));
                        }

                    // Handle unexpected responses
                    } else {
                        const text = await response.text();
                        debugLog('Unexpected response received', {
                            contentType,
                            response: text.substring(0, 500)
                        });
                        throw new Error('Unexpected response type: ' + contentType);
                    }

                } else {
                    const errorText = await response.text();
                    debugLog('Avatar generation failed', { status: response.status, error: errorText });
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

            } catch (err) {
                debugLog('Avatar generation error', { error: err.message });
                if (error) {
                    error.textContent = 'Generation Error: ' + err.message;
                    error.style.display = 'block';
                }
                showNotification('Avatar generation failed: ' + err.message, 'error');
            } finally {
                generationInProgress = false;
                if (loading) {
                    loading.style.display = 'none';
                    loading.classList.remove('show');
                }
            }
        }

// Enhanced streaming response handler function
async function handleStreamingResponse(response, video, videoInfo, payload, duration) {
    const reader = response.body.getReader();
    let buffer = new Uint8Array();
    let chunks = [];
    let currentChunk = null;
    let videoFrames = [];
    let videoChunks = []; // Add support for video chunk URLs

    try {
        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            // Append new data to buffer
            const newBuffer = new Uint8Array(buffer.length + value.length);
            newBuffer.set(buffer);
            newBuffer.set(value, buffer.length);
            buffer = newBuffer;

            // Convert to string for boundary detection
            const bufferString = new TextDecoder('latin1').decode(buffer);

            // Look for multipart boundaries
            const boundaryPattern = /--frame\r?\n/g;
            let lastBoundaryEnd = 0;
            let match;

            while ((match = boundaryPattern.exec(bufferString)) !== null) {
                const frameStart = lastBoundaryEnd;
                const frameEnd = match.index;

                if (frameStart < frameEnd) {
                    const frameData = buffer.slice(frameStart, frameEnd);
                    await processFrame(frameData, chunks, currentChunk, videoFrames, videoChunks);
                }

                lastBoundaryEnd = boundaryPattern.lastIndex;
            }

            // Keep remaining data in buffer
            if (lastBoundaryEnd > 0) {
                buffer = buffer.slice(lastBoundaryEnd);
            }
        }

        // Process any remaining data
        if (buffer.length > 0) {
            await processFrame(buffer, chunks, currentChunk, videoFrames, videoChunks);
        }

        // Handle different response types
        if (videoChunks.length > 0) {
            // Chunked video URLs - play sequentially
            debugLog('Playing video chunks sequentially', { chunkCount: videoChunks.length });
            await playVideoChunksSequentially(video, videoChunks);

        } else if (videoFrames.length > 0) {
            // JPEG frames or complete video
            debugLog('Combining video frames', { frameCount: videoFrames.length });

            const lastFrame = videoFrames[videoFrames.length - 1];
            const frameHeader = new Uint8Array(lastFrame.slice(0, 10));
            const isJpeg = frameHeader[0] === 0xFF && frameHeader[1] === 0xD8;

            if (isJpeg && videoFrames.length > 10) {
                // JPEG frames from realtime streaming - create animated display
                debugLog('Processing JPEG frames for animation', {
                    frameCount: videoFrames.length,
                    totalChunks: chunks.length
                });

                createJpegAnimation(video, videoFrames);

            } else {
                // Regular video data - treat as MP4
                const videoBlob = new Blob([lastFrame], { type: 'video/mp4' });
                const videoUrl = URL.createObjectURL(videoBlob);

                if (video) {
                    video.src = videoUrl;
                    video.style.display = 'block';

                    // Remove any existing canvas
                    const existingCanvas = video.parentNode.querySelector('.jpeg-animation-canvas');
                    if (existingCanvas) {
                        existingCanvas.remove();
                    }

                    debugLog('Video source set', {
                        blobSize: videoBlob.size,
                        frameCount: videoFrames.length
                    });
                }
            }
        } else {
            debugLog('No video content to display');
            showNotification('No video content received in stream', 'warning');
        }

        // Update video info for streaming
        if (videoInfo) {
            videoInfo.innerHTML = `
                <strong>Streaming Complete!</strong><br>
                Mode: Streaming (${payload.stream_mode})<br>
                Engine: ${payload.tts_engine}<br>
                Voice: ${payload.tts_voice}<br>
                Chunks: ${chunks.length}<br>
                Video Frames: ${videoFrames.length}<br>
                Video Chunks: ${videoChunks.length}<br>
                Total Duration: ${chunks.reduce((sum, c) => sum + (c.duration || 0), 0).toFixed(2)}s<br>
                Stream Time: ${(duration / 1000).toFixed(1)}s<br>
                Parameters: ${Object.keys(payload).length} options used
            `;
        }

        debugLog('Streaming completed', {
            totalChunks: chunks.length,
            videoFrames: videoFrames.length,
            videoChunks: videoChunks.length,
            streamDuration: duration
        });

    } catch (streamError) {
        debugLog('Streaming error', { error: streamError.message });
        throw streamError;
    }
}

// Updated processFrame function to handle video chunk URLs
async function processFrame(frameData, chunks, currentChunk, videoFrames, videoChunks) {
    const frameString = new TextDecoder('utf-8').decode(frameData);

    // Parse headers
    const headerEnd = frameString.indexOf('\r\n\r\n');
    if (headerEnd === -1) return;

    const headers = frameString.substring(0, headerEnd);
    const contentStart = headerEnd + 4;

    // Extract content type
    const contentTypeMatch = headers.match(/Content-Type:\s*([^\r\n]+)/i);
    const contentType = contentTypeMatch ? contentTypeMatch[1].trim() : 'unknown';

    debugLog('Frame processed', {
        headersLength: headers.length,
        contentLength: frameData.length - contentStart,
        contentType: contentType
    });

    if (contentType === 'application/json') {
        // Parse JSON metadata
        const jsonData = frameString.substring(contentStart).trim();
        try {
            const data = JSON.parse(jsonData);
            debugLog('Chunk metadata received', data);

            // Handle video chunk URLs from chunked streaming
            if (data.video_url && data.ready) {
                videoChunks.push({
                    id: data.chunk_id,
                    url: data.video_url,
                    duration: data.duration,
                    sentence: data.sentence,
                    mode: data.mode
                });
                debugLog('Video chunk URL received', {
                    chunkId: data.chunk_id,
                    url: data.video_url,
                    duration: data.duration
                });
            }

            chunks.push(data);
        } catch (parseError) {
            debugLog('JSON parse error', { error: parseError.message, data: jsonData });
        }
    } else if (contentType === 'image/jpeg') {
        // Handle JPEG frame data from realtime streaming
        const frameDataSlice = frameData.slice(contentStart);
        videoFrames.push(frameDataSlice);

        debugLog('JPEG frame received', {
            chunkId: currentChunk ? currentChunk.id : 'unknown',
            dataSize: frameDataSlice.length
        });
    }
}

// Function to play video chunks sequentially
async function playVideoChunksSequentially(video, videoChunks) {
    if (!video || videoChunks.length === 0) return;

    // Sort chunks by ID to ensure correct order
    videoChunks.sort((a, b) => a.id - b.id);

    // Hide any existing canvas
    const existingCanvas = video.parentNode.querySelector('.jpeg-animation-canvas');
    if (existingCanvas) {
        existingCanvas.style.display = 'none';
    }

    video.style.display = 'block';

    let currentChunkIndex = 0;
    let totalDuration = 0;

    const playNextChunk = () => {
        if (currentChunkIndex >= videoChunks.length) {
            debugLog('All video chunks played');
            showNotification('Video playback complete!', 'success');
            return;
        }

        const chunk = videoChunks[currentChunkIndex];
        debugLog('Playing video chunk', {
            chunkId: chunk.id,
            url: chunk.url,
            duration: chunk.duration
        });

        // Update video source
        video.src = chunk.url;

        // Play current chunk
        video.play().then(() => {
            showNotification(`Playing chunk ${chunk.id + 1}/${videoChunks.length}: "${chunk.sentence.substring(0, 30)}..."`, 'info');
        }).catch(error => {
            debugLog('Video play error', { error: error.message, chunkId: chunk.id });
            showNotification(`Error playing chunk ${chunk.id + 1}`, 'error');
            // Try next chunk
            currentChunkIndex++;
            setTimeout(playNextChunk, 500);
        });

        totalDuration += chunk.duration || 0;
        currentChunkIndex++;
    };

    // Set up event listener for when video ends
    const onVideoEnded = () => {
        debugLog('Video chunk ended', { chunkIndex: currentChunkIndex - 1 });

        // Small delay before playing next chunk
        setTimeout(playNextChunk, 100);
    };

    video.addEventListener('ended', onVideoEnded);

    // Clean up event listener when all chunks are done
    const originalChunkCount = videoChunks.length;
    const checkCompletion = setInterval(() => {
        if (currentChunkIndex >= originalChunkCount) {
            video.removeEventListener('ended', onVideoEnded);
            clearInterval(checkCompletion);
        }
    }, 500);

    // Start playing first chunk
    playNextChunk();
}

// Function to create JPEG animation (extracted from original function)
function createJpegAnimation(video, videoFrames) {
    if (!video) return;

    // Hide the video element and create a canvas animation
    video.style.display = 'none';

    // Create canvas for JPEG frame animation
    let canvas = video.parentNode.querySelector('.jpeg-animation-canvas');
    if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.className = 'jpeg-animation-canvas';
        canvas.style.maxWidth = '100%';
        canvas.style.height = 'auto';
        canvas.style.border = '2px solid #555';
        canvas.style.borderRadius = '8px';
        canvas.style.cursor = 'pointer';
        video.parentNode.insertBefore(canvas, video);
    }

    canvas.style.display = 'block';

    // Set up canvas animation
    const ctx = canvas.getContext('2d');
    let currentFrameIndex = 0;
    let animationPlaying = false;
    let animationInterval;

    // Load first frame to set canvas size
    const firstImg = new Image();
    firstImg.onload = function() {
        canvas.width = firstImg.width;
        canvas.height = firstImg.height;
        ctx.drawImage(firstImg, 0, 0);

        // Add play button overlay
        drawPlayButton(ctx, canvas.width, canvas.height);

        debugLog('Canvas initialized', {
            width: canvas.width,
            height: canvas.height,
            totalFrames: videoFrames.length
        });
    };

    // Function to draw play button
    function drawPlayButton(context, width, height) {
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) * 0.08;

        // Draw semi-transparent background
        context.fillStyle = 'rgba(0, 0, 0, 0.6)';
        context.beginPath();
        context.arc(centerX, centerY, radius, 0, 2 * Math.PI);
        context.fill();

        // Draw play triangle
        context.fillStyle = 'white';
        context.beginPath();
        context.moveTo(centerX - radius * 0.3, centerY - radius * 0.4);
        context.lineTo(centerX + radius * 0.4, centerY);
        context.lineTo(centerX - radius * 0.3, centerY + radius * 0.4);
        context.closePath();
        context.fill();
    }

    // Set up click handler for play/pause
    canvas.onclick = function(event) {
        debugLog('Canvas clicked', {
            animationPlaying: animationPlaying,
            frameCount: videoFrames.length
        });

        if (animationPlaying) {
            // Pause animation
            clearInterval(animationInterval);
            animationPlaying = false;

            // Show play button again
            drawPlayButton(ctx, canvas.width, canvas.height);
            debugLog('Animation paused');
            showNotification('Animation paused', 'info');
        } else {
            // Start animation
            if (videoFrames.length === 0) {
                showNotification('No frames to animate', 'error');
                return;
            }

            animationPlaying = true;
            currentFrameIndex = 0;
            const fps = 15; // Animation FPS
            const frameDuration = 1000 / fps;

            debugLog('Starting animation', {
                fps: fps,
                totalFrames: videoFrames.length,
                frameDuration: frameDuration
            });

            showNotification('Animation started - Click to pause', 'success');

            animationInterval = setInterval(() => {
                try {
                    if (currentFrameIndex >= videoFrames.length) {
                        currentFrameIndex = 0; // Loop back to start
                    }

                    const frameData = videoFrames[currentFrameIndex];
                    const frameBlob = new Blob([frameData], { type: 'image/jpeg' });
                    const frameUrl = URL.createObjectURL(frameBlob);

                    const frameImg = new Image();
                    frameImg.onload = function() {
                        if (animationPlaying) { // Check if still playing
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(frameImg, 0, 0);
                        }
                        URL.revokeObjectURL(frameUrl);
                    };
                    frameImg.onerror = function() {
                        debugLog('Frame load error', { frameIndex: currentFrameIndex });
                    };
                    frameImg.src = frameUrl;

                    currentFrameIndex++;
                } catch (error) {
                    debugLog('Animation frame error', { error: error.message });
                }
            }, frameDuration);
        }
    };

    // Add hover effect
    canvas.onmouseover = function() {
        canvas.style.opacity = '0.9';
        canvas.style.cursor = 'pointer';
    };
    canvas.onmouseout = function() {
        canvas.style.opacity = '1.0';
    };

    // Create first frame blob URL
    const firstFrameBlob = new Blob([videoFrames[0]], { type: 'image/jpeg' });
    const firstFrameUrl = URL.createObjectURL(firstFrameBlob);
    firstImg.src = firstFrameUrl;

    debugLog('JPEG animation canvas created', {
        frameCount: videoFrames.length,
        canvasSize: `${canvas.width}x${canvas.height}`
    });
}
async function processFrame(frameData, chunks, currentChunk, videoFrames) {
                try {
                    const frameString = new TextDecoder('latin1').decode(frameData);
                    const headerEndIndex = frameString.indexOf('\r\n\r\n');

                    if (headerEndIndex === -1) {
                        // No complete headers found
                        return;
                    }

                    const headers = frameString.substring(0, headerEndIndex);
                    const contentStart = headerEndIndex + 4;
                    const contentData = frameData.slice(contentStart);

                    debugLog('Frame processed', {
                        headersLength: headers.length,
                        contentLength: contentData.length,
                        contentType: headers.match(/Content-Type:\s*([^\r\n]+)/i)?.[1] || 'unknown'
                    });

                    if (headers.includes('application/json')) {
                        // Parse chunk metadata
                        const contentText = new TextDecoder('utf-8').decode(contentData);
                        const chunkData = JSON.parse(contentText);
                        currentChunk = chunkData;
                        chunks.push(chunkData);

                        debugLog('Chunk metadata received', chunkData);
                        updateProgress(
                            70 + (chunkData.chunk_id / (chunkData.total_chunks || 1)) * 20,
                            `Processing chunk ${chunkData.chunk_id + 1}/${chunkData.total_chunks || 1}: "${chunkData.sentence}"`
                        );

                    } else if (headers.includes('video/mp4') || headers.includes('application/octet-stream')) {
                        // Handle video data
                        debugLog('Video frame received', {
                            chunkId: currentChunk?.chunk_id || 'unknown',
                            dataSize: contentData.length,
                            headers: headers.substring(0, 100)
                        });

                        if (contentData.length > 1000) { // Only consider substantial video data
                            videoFrames.push(contentData);
                        }
                    } else if (headers.includes('image/jpeg') || headers.includes('image/jpg')) {
                        // Handle JPEG frame data - convert to video
                        debugLog('JPEG frame received', {
                            chunkId: currentChunk?.chunk_id || 'unknown',
                            dataSize: contentData.length
                        });

                        if (contentData.length > 1000) { // Only consider substantial image data
                            videoFrames.push(contentData);
                        }
                    }
                } catch (parseError) {
                    debugLog('Frame parsing error', {
                        error: parseError.message,
                        frameSize: frameData.length
                    });
                }
            }


        // Video Management
        function downloadVideo() {
            const video = document.getElementById('avatarVideo');
            if (video && video.src) {
                const a = document.createElement('a');
                a.href = video.src;
                a.download = `avatar_${new Date().getTime()}.mp4`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                showNotification('Video download started', 'success');
            } else {
                showNotification('No video available to download', 'error');
            }
        }

        function shareVideo() {
            const video = document.getElementById('avatarVideo');
            if (video && video.src) {
                if (navigator.share) {
                    navigator.share({
                        title: 'Generated Avatar Video',
                        text: 'Check out this AI-generated avatar!',
                        url: video.src
                    }).then(() => {
                        showNotification('Video shared successfully', 'success');
                    }).catch(() => {
                        showNotification('Sharing failed', 'error');
                    });
                } else {
                    // Fallback: copy URL to clipboard
                    if (navigator.clipboard) {
                        navigator.clipboard.writeText(video.src).then(() => {
                            showNotification('Video URL copied to clipboard', 'success');
                        }).catch(() => {
                            showNotification('Could not copy URL', 'error');
                        });
                    } else {
                        showNotification('Sharing not supported', 'error');
                    }
                }
            } else {
                showNotification('No video available to share', 'error');
            }
        }

        // API Functions
        async function getEngines() {
            debugLog('Getting TTS engines and voices');

            try {
                const response = await fetch('/web/api/avatar_dual.php?action=engines');
                const result = await response.json();

                if (result.engines) {
                    debugLog('TTS engines received', result.engines);
                    displayEngineInfo(result.engines);
                } else {
                    debugLog('No engine data received');
                    showNotification('No engine data received', 'warning');
                }

            } catch (error) {
                debugLog('Engine retrieval error', { error: error.message });
                showNotification('Failed to get TTS engines: ' + error.message, 'error');
            }
        }

        function displayEngineInfo(engines) {
            let info = "Available TTS Engines:\n\n";
            Object.entries(engines).forEach(([key, engine]) => {
                info += `${engine.name}:\n`;
                info += `  Voices: ${engine.voices ? engine.voices.length : 'Unknown'}\n`;
                info += `  Speed Range: ${engine.speed_range ? engine.speed_range[0] + '-' + engine.speed_range[1] : 'Unknown'}\n`;
                info += `  Pitch Range: ${engine.pitch_range ? engine.pitch_range[0] + '-' + engine.pitch_range[1] : 'Unknown'}\n\n`;
            });

            alert(info);
        }

        async function testMP4() {
            debugLog('Testing MP4 pipeline');

            const video = document.getElementById('avatarVideo');
            const result = document.getElementById('result');
            const error = document.getElementById('error');

            try {
                const response = await fetch('/test-mp4');

                if (response.ok) {
                    const blob = await response.blob();
                    const videoUrl = URL.createObjectURL(blob);

                    if (video) video.src = videoUrl;
                    if (result) result.style.display = 'block';
                    if (error) error.style.display = 'none';

                    debugLog('Test MP4 loaded successfully', {
                        size: blob.size,
                        type: blob.type
                    });

                    showNotification('Test MP4 loaded successfully', 'success');

                } else {
                    throw new Error(`Test MP4 failed: ${response.status}`);
                }

            } catch (err) {
                debugLog('Test MP4 failed', { error: err.message });
                if (error) {
                    error.textContent = 'Test MP4 Error: ' + err.message;
                    error.style.display = 'block';
                }
                showNotification('Test MP4 failed', 'error');
            }
        }

        async function testConnection() {
            debugLog('Testing avatar service connection');

            try {
                const response = await fetch('/web/api/avatar_dual.php?action=test');
                const result = await response.json();

                debugLog('Connection test result', result);

                if (result.status === 'success') {
                    showNotification('Connection successful: ' + result.message, 'success');
                } else {
                    showNotification('Connection failed: ' + result.message, 'error');
                }
            } catch (error) {
                debugLog('Connection test error', { error: error.message });
                showNotification('Connection test failed: ' + error.message, 'error');
            }
        }

        async function pingAllServers() {
            debugLog('Pinging all servers');
            showNotification('Pinging servers...', 'info');

            try {
                // This would need to be implemented in the API
                await refreshPeerInfo();
                showNotification('Server ping completed', 'success');
            } catch (error) {
                showNotification('Server ping failed', 'error');
            }
        }

        async function benchmarkServers() {
            debugLog('Benchmarking servers');
            showNotification('Benchmarking servers... This may take a while', 'info');

            // This would need to be implemented as a special API endpoint
            // that tests generation speed on each available server
            setTimeout(() => {
                showNotification('Benchmark feature coming soon', 'info');
            }, 2000);
        }

        async function getServerInfo() {
            debugLog('Getting server connection info');

            try {
                const response = await fetch('/web/api/avatar_dual.php?action=server_info');
                const result = await response.json();

                debugLog('Server info received', result);
                displayServerInfo(result);

            } catch (error) {
                debugLog('Server info retrieval error', { error: error.message });
                showNotification('Failed to get server info', 'error');
            }
        }

        function displayServerInfo(info) {
            const container = document.getElementById('serverInfo');
            if (!container) return;

            if (!info || !info.current_peer) {
                container.innerHTML = '<div class="status-item status-error">No server info available</div>';
                return;
            }

            const peer = info.current_peer;
            const available = info.available_peers || [];

            let html = `
                <div class="status-item status-${peer.type === 'local' ? 'warning' : 'ok'}">
                    <strong>Current Avatar Server:</strong><br>
                    ${peer.name}<br>
                    Type: ${peer.type}<br>
                    ${peer.ip ? `IP: ${peer.ip}<br>` : ''}
                    ${peer.gpu_memory ? `GPU: ${peer.gpu_memory}GB<br>` : ''}
                    ${peer.memory ? `RAM: ${peer.memory}GB` : ''}
                </div>
            `;

            if (available.length > 0) {
                html += `
                    <div class="status-item status-ok">
                        <strong>Available Servers:</strong><br>
                        ${available.map(p => `${p.name} (${p.type})`).join('<br>')}
                    </div>
                `;
            }

            container.innerHTML = html;

            // Update current peer display
            const currentDisplay = document.getElementById('currentPeerDisplay');
            if (currentDisplay) {
                currentDisplay.innerHTML = `
                    <div class="peer-option selected">
                        <div>
                            <strong>${peer.name}</strong> (${peer.type})<br>
                            <small>Currently active server</small>
                        </div>
                    </div>
                `;
            }
        }

        async function getStatus() {
            debugLog('Getting system status');

            try {
                const response = await fetch('/web/api/avatar_dual.php?action=status');
                const result = await response.json();

                debugLog('System status received', result);
                displayStatus(result.data || result);

            } catch (error) {
                debugLog('Status retrieval error', { error: error.message });
                showNotification('Failed to get system status', 'error');
            }
        }

        async function getDetailedStatus() {
            debugLog('Getting detailed system status');
            showNotification('Getting detailed status...', 'info');

            try {
                await getStatus();
                // Additional detailed status calls could be made here
                showNotification('Detailed status retrieved', 'success');
            } catch (error) {
                showNotification('Failed to get detailed status', 'error');
            }
        }

        async function exportStatus() {
            debugLog('Exporting system status');

            try {
                const response = await fetch('/web/api/avatar_dual.php?action=status');
                const result = await response.json();

                const statusData = JSON.stringify(result, null, 2);
                const blob = new Blob([statusData], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `avatar_status_${new Date().toISOString()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showNotification('Status exported successfully', 'success');
            } catch (error) {
                showNotification('Failed to export status', 'error');
            }
        }

        function displayStatus(status) {
            const grid = document.getElementById('statusGrid');
            if (!grid) return;

            if (!status) {
                grid.innerHTML = '<div class="status-item status-error">No status data available</div>';
                return;
            }

            const items = [
                { label: 'Timestamp', value: status.timestamp || 'Unknown', status: 'ok' },
                { label: 'Device', value: status.device || 'Unknown', status: 'ok' },
                { label: 'TTS Ready', value: status.tts_ready ? 'Yes' : 'No', status: status.tts_ready ? 'ok' : 'error' },
                { label: 'SadTalker Installed', value: status.sadtalker_installed ? 'Yes' : 'No', status: status.sadtalker_installed ? 'ok' : 'warning' },
                { label: 'Streaming Available', value: status.streaming_available ? 'Yes' : 'No', status: status.streaming_available ? 'ok' : 'warning' },
                { label: 'Default Codec', value: status.default_codec || 'Unknown', status: 'ok' },
                { label: 'GPU Available', value: status.gpu_available ? 'Yes' : 'No', status: status.gpu_available ? 'ok' : 'warning' },
                { label: 'Memory Usage', value: status.memory_usage || 'Unknown', status: 'ok' }
            ];

            grid.innerHTML = items.map(item => `
                <div class="status-item status-${item.status}">
                    <strong>${item.label}:</strong><br>
                    ${item.value}
                </div>
            `).join('');
        }

        async function getLogs() {
            debugLog('Getting avatar service logs');

            try {
                const response = await fetch('/web/api/avatar_dual.php?action=logs');
                const result = await response.json();

                debugLog('Logs received', { logCount: result.data?.logs?.length || 0 });

                const container = document.getElementById('logContainer');
                if (container) {
                    if (result.data && result.data.logs) {
                        const logText = Array.isArray(result.data.logs) ? result.data.logs.join('\n') : result.data.logs;
                        container.innerHTML = logText;
                        container.setAttribute('data-all-logs', logText);
                    } else {
                        container.innerHTML = 'No logs available';
                    }
                }

                showNotification('Logs retrieved successfully', 'success');

            } catch (error) {
                debugLog('Log retrieval error', { error: error.message });
                showNotification('Failed to retrieve logs', 'error');
            }
        }

        // Log Management
        function refreshStatus() {
            getStatus();
        }

        function refreshLogs() {
            getLogs();
        }

        function clearLogs() {
            const container = document.getElementById('logContainer');
            if (container) {
                container.innerHTML = 'Logs cleared';
            }
            debugLog('Debug logs cleared');
            showNotification('Logs cleared', 'info');
        }

        function clearDebugLogs() {
            const container = document.getElementById('logContainer');
            if (container) {
                container.innerHTML = 'Debug logs cleared';
            }
            console.clear();
            debugLog('Debug console cleared');
            showNotification('Debug logs cleared', 'info');
        }

        function downloadLogs() {
            const container = document.getElementById('logContainer');
            if (container) {
                const logs = container.textContent;
                const blob = new Blob([logs], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `avatar_debug_logs_${new Date().toISOString()}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                debugLog('Debug logs downloaded');
                showNotification('Logs downloaded', 'success');
            }
        }

        function copyLogsToClipboard() {
            const container = document.getElementById('logContainer');
            if (container && navigator.clipboard) {
                const logs = container.textContent;
                navigator.clipboard.writeText(logs).then(() => {
                    debugLog('Debug logs copied to clipboard');
                    showNotification('Logs copied to clipboard', 'success');
                }).catch(err => {
                    debugLog('Failed to copy logs to clipboard', { error: err.message });
                    showNotification('Failed to copy logs', 'error');
                });
            } else {
                showNotification('Clipboard not available', 'error');
            }
        }

        function filterLogs() {
            const searchTerm = prompt('Enter search term for logs:');
            if (searchTerm) {
                searchLogs(searchTerm);
            }
        }

        function filterLogsByLevel() {
            const levelSelect = document.getElementById('logLevel');
            const level = levelSelect ? levelSelect.value : 'all';
            const container = document.getElementById('logContainer');

            if (!container) return;

            const allLogs = container.getAttribute('data-all-logs') || container.textContent;

            if (level === 'all') {
                container.innerHTML = allLogs;
            } else {
                const filteredLogs = allLogs.split('\n').filter(line =>
                    line.toLowerCase().includes(level.toLowerCase())
                ).join('\n');
                container.innerHTML = filteredLogs || 'No logs found for this level';
            }
        }

        function searchLogs(searchTerm = null) {
            const searchInput = document.getElementById('logSearch');
            const term = searchTerm || (searchInput ? searchInput.value : '');
            const container = document.getElementById('logContainer');

            if (!container) return;

            const allLogs = container.getAttribute('data-all-logs') || container.textContent;

            if (!term) {
                container.innerHTML = allLogs;
                return;
            }

            const filteredLogs = allLogs.split('\n').filter(line =>
                line.toLowerCase().includes(term.toLowerCase())
            ).join('\n');

            container.innerHTML = filteredLogs || 'No logs found for search term';
        }

        // Drag and Drop for Image Upload
        function setupDragAndDrop() {
            const uploadZone = document.querySelector('.image-upload-zone');

            if (uploadZone) {
                uploadZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadZone.classList.add('dragover');
                });

                uploadZone.addEventListener('dragleave', () => {
                    uploadZone.classList.remove('dragover');
                });

                uploadZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadZone.classList.remove('dragover');

                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        const fileInput = document.getElementById('imageFile');
                        if (fileInput) {
                            fileInput.files = files;
                            handleImageUpload({ target: fileInput });
                        }
                    }
                });
            }
        }

        // Initialize
        function initializeDebugConsole() {
            debugLog('Complete Avatar Debug Console initializing');

            // Set default TTS engine
            updateTTSOptions();

            // Initialize range displays
            updateRangeDisplay('speed', document.getElementById('ttsSpeed')?.value || '160');
            updateRangeDisplay('pitch', document.getElementById('ttsPitch')?.value || '0');
            updateRangeDisplay('confidence', document.getElementById('faceConfidence')?.value || '0.5');
            updateRangeDisplay('expression', document.getElementById('expressionScale')?.value || '1.0');

            // Setup drag and drop
            setupDragAndDrop();

            // Load initial data
            getServerInfo();
            getStatus();
            loadAvailablePeers();

            debugLog('Initialization complete - ALL options loaded');
            showNotification('Avatar Debug Console initialized', 'success');
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeDebugConsole);
        } else {
            initializeDebugConsole();
        }
    </script>
</body>
</html>