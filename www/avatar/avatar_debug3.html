<!DOCTYPE html>
<html>
<head>
    <title>ZeroAI Avatar Debug Console - Fixed Streaming</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #fff;
            min-height: 100vh;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(90deg, #007cba, #4CAF50);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        .section {
            background: linear-gradient(145deg, #2a2a2a, #3a3a3a);
            padding: 25px;
            margin: 25px 0;
            border-radius: 12px;
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.3);
            border: 1px solid #444;
        }
        .section h2 {
            margin-top: 0;
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
            font-size: 1.5em;
        }
        .option-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .option-group {
            background: linear-gradient(145deg, #333, #404040);
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #555;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        .option-group h4 {
            margin: 0 0 15px 0;
            color: #4CAF50;
            font-size: 1.1em;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 5px;
        }
        .controls {
            display: flex;
            gap: 12px;
            margin: 15px 0;
            flex-wrap: wrap;
            align-items: center;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            flex-wrap: wrap;
        }
        button {
            padding: 12px 24px;
            background: linear-gradient(145deg, #007cba, #0056b3);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 124, 186, 0.3);
        }
        button:hover {
            background: linear-gradient(145deg, #0056b3, #004085);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 124, 186, 0.4);
        }
        button:active {
            transform: translateY(0);
        }
        button.danger {
            background: linear-gradient(145deg, #dc3545, #c82333);
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
        }
        button.danger:hover {
            background: linear-gradient(145deg, #c82333, #bd2130);
        }
        button.success {
            background: linear-gradient(145deg, #28a745, #1e7e34);
            box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
        }
        button.success:hover {
            background: linear-gradient(145deg, #1e7e34, #155724);
        }
        button.generate {
            background: linear-gradient(145deg, #28a745, #20c997);
            font-size: 18px;
            padding: 15px 30px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }
        input, select, textarea {
            background: linear-gradient(145deg, #333, #404040);
            color: #fff;
            border: 1px solid #555;
            padding: 10px;
            border-radius: 6px;
            transition: all 0.3s ease;
        }
        input:focus, select:focus, textarea:focus {
            border-color: #4CAF50;
            outline: none;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.3);
        }
        input[type="file"] {
            padding: 6px;
            background: #444;
        }
        input[type="range"] {
            width: 150px;
            accent-color: #4CAF50;
        }
        input[type="number"] {
            width: 80px;
        }
        input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
            accent-color: #4CAF50;
        }
        input[type="radio"] {
            accent-color: #4CAF50;
            margin-right: 5px;
        }
        textarea {
            width: 100%;
            height: 100px;
            resize: vertical;
            font-family: inherit;
        }
        .log-container {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            padding: 20px;
            height: 300px;
            overflow-y: auto;
            border: 1px solid #333;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.4;
        }
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        .status-item {
            background: linear-gradient(145deg, #333, #404040);
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #666;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        .status-ok {
            border-left-color: #28a745;
        }
        .status-error {
            border-left-color: #dc3545;
        }
        .status-warning {
            border-left-color: #ffc107;
        }
        video {
            width: 100%;
            max-width: 600px;
            border: 2px solid #555;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        .debug-info {
            background: linear-gradient(145deg, #1a1a2e, #2d2d4a);
            padding: 15px;
            margin: 15px 0;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            border: 1px solid #444;
        }
        .loading {
            display: none;
            color: #ffc107;
            text-align: center;
            padding: 20px;
            font-size: 16px;
        }
        .loading.show {
            display: block;
        }
        .error {
            color: #dc3545;
            background: rgba(220, 53, 69, 0.1);
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #dc3545;
            margin: 15px 0;
        }
        .success {
            color: #28a745;
            background: rgba(40, 167, 69, 0.1);
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #28a745;
            margin: 15px 0;
        }
        .image-preview {
            max-width: 200px;
            max-height: 200px;
            border: 2px solid #555;
            margin: 10px 0;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .tabs {
            display: flex;
            background: #333;
            border-radius: 8px 8px 0 0;
            overflow: hidden;
            margin-top: 20px;
        }
        .tab {
            padding: 15px 25px;
            cursor: pointer;
            background: #444;
            border-right: 1px solid #555;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        .tab:hover {
            background: #555;
        }
        .tab.active {
            background: linear-gradient(145deg, #007cba, #0056b3);
            color: white;
        }
        .tab-content {
            display: none;
            background: linear-gradient(145deg, #333, #404040);
            padding: 25px;
            border-radius: 0 0 8px 8px;
            border: 1px solid #555;
            border-top: none;
        }
        .tab-content.active {
            display: block;
        }
        label {
            display: inline-block;
            min-width: 130px;
            color: #ccc;
            font-weight: 500;
        }
        .range-display {
            color: #4CAF50;
            font-weight: bold;
            margin-left: 12px;
            min-width: 40px;
            display: inline-block;
        }
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.3s ease;
        }
        .image-upload-zone {
            border: 2px dashed #555;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 10px 0;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .image-upload-zone:hover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.05);
        }
        .image-upload-zone.dragover {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }
        .peer-selector {
            background: #333;
            border: 1px solid #555;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
        }
        .peer-option {
            display: flex;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .peer-option:hover {
            background: #444;
        }
        .peer-option.selected {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
        }
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 6px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }
        .notification.show {
            transform: translateX(0);
        }
        .notification.success {
            background: linear-gradient(145deg, #28a745, #20c997);
        }
        .notification.error {
            background: linear-gradient(145deg, #dc3545, #c82333);
        }
        .notification.info {
            background: linear-gradient(145deg, #007cba, #0056b3);
        }
        .jpeg-animation-canvas {
            max-width: 100%;
            height: auto;
            border: 2px solid #555;
            border-radius: 8px;
            cursor: pointer;
        }
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            .option-grid {
                grid-template-columns: 1fr;
            }
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            .tabs {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>ZeroAI Avatar Debug Console</h1>
        <p>Complete Avatar Generation System with Fixed Streaming Support</p>
    </div>

    <div class="section">
        <h2>Avatar Generation Center</h2>

        <!-- Mode Selection -->
        <div class="control-group">
            <label><strong>Generation Mode:</strong></label>
            <input type="radio" id="mode-simple" name="mode" value="simple" checked>
            <label for="mode-simple" style="min-width: auto; margin-right: 20px;">Simple Avatar</label>
            <input type="radio" id="mode-sadtalker" name="mode" value="sadtalker">
            <label for="mode-sadtalker" style="min-width: auto;">SadTalker (Realistic)</label>
        </div>

        <!-- Stream Mode -->
        <div class="control-group">
            <label for="streamMode"><strong>Stream Mode:</strong></label>
            <select id="streamMode">
                <option value="complete">Complete (Full video)</option>
                <option value="chunked">Chunked Streaming</option>
                <option value="realtime">Realtime Streaming</option>
            </select>
        </div>

        <!-- Prompt -->
        <div style="margin: 20px 0;">
            <label for="prompt"><strong>Prompt:</strong></label>
            <textarea id="prompt" placeholder="Enter your prompt here...">Hello! This is a comprehensive test of the avatar system with all available options enabled.</textarea>
        </div>

        <!-- Action Buttons -->
        <div class="controls" style="margin-top: 30px; justify-content: center;">
            <button onclick="generateAvatar()" class="generate">Generate Avatar</button>
            <button onclick="testMP4()" class="success">Test MP4 Pipeline</button>
            <button onclick="testConnection()" class="success">Test Connection</button>
            <button onclick="getEngines()">Get TTS Engines</button>
            <button onclick="getStatus()">Get Status</button>
            <button onclick="getLogs()">Get Logs</button>
            <button onclick="clearLogs()" class="danger">Clear Logs</button>
        </div>

        <div class="loading" id="loading">
            <p>Generating avatar... This may take a few minutes.</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="progressText">Initializing...</div>
        </div>

        <div id="result" style="display: none;">
            <h3>Generated Avatar:</h3>
            <video id="avatarVideo" controls>
                Your browser does not support the video tag.
            </video>
            <div class="debug-info" id="videoInfo"></div>
            <div class="controls">
                <button onclick="downloadVideo()" class="success">Download Video</button>
                <button onclick="shareVideo()" class="success">Share Video</button>
            </div>
        </div>

        <div id="error" class="error" style="display: none;"></div>
    </div>

    <!-- Debug Logs -->
    <div class="section">
        <h2>Debug Logs</h2>
        <div class="log-container" id="logContainer">
            Click "Get Logs" to load debug information...
        </div>
    </div>
</div>

<!-- Notification Container -->
<div id="notification" class="notification"></div>

<script>
    let debugMode = true;
    let currentMode = 'simple';
    let generationInProgress = false;

    // Utility Functions
    function debugLog(message, data = null) {
        const timestamp = new Date().toISOString();
        console.log(`[${timestamp}] ${message}`, data || '');

        if (debugMode) {
            const logEntry = `${timestamp}: ${message}${data ? ' - ' + JSON.stringify(data, null, 2) : ''}`;
            appendToLog('logContainer', logEntry);
        }
    }

    function appendToLog(containerId, message) {
        const container = document.getElementById(containerId);
        if (container) {
            container.innerHTML += message + '\n';
            container.scrollTop = container.scrollHeight;
        }
    }

    function showNotification(message, type = 'info', duration = 3000) {
        const notification = document.getElementById('notification');
        if (notification) {
            notification.textContent = message;
            notification.className = `notification ${type} show`;

            setTimeout(() => {
                notification.classList.remove('show');
            }, duration);
        }
    }

    function updateProgress(percent, text = '') {
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');

        if (progressFill) progressFill.style.width = percent + '%';
        if (progressText && text) progressText.textContent = text;
    }

    // FIXED: Main Generation Function with proper streaming support
    async function generateAvatar() {
        if (generationInProgress) {
            showNotification('Generation already in progress', 'warning');
            return;
        }

        const loading = document.getElementById('loading');
        const result = document.getElementById('result');
        const error = document.getElementById('error');
        const video = document.getElementById('avatarVideo');
        const videoInfo = document.getElementById('videoInfo');

        // Get form values safely
        const getElementValue = (id, defaultValue = '') => {
            const element = document.getElementById(id);
            return element ? element.value : defaultValue;
        };

        const getRadioValue = (name, defaultValue = '') => {
            const radio = document.querySelector(`input[name="${name}"]:checked`);
            return radio ? radio.value : defaultValue;
        };

        // Collect payload
        const payload = {
            prompt: getElementValue('prompt'),
            mode: getRadioValue('mode', 'simple'),
            stream_mode: getElementValue('streamMode')
        };

        debugLog('Starting avatar generation', payload);
        generationInProgress = true;

        if (loading) {
            loading.style.display = 'block';
            loading.classList.add('show');
        }
        if (result) result.style.display = 'none';
        if (error) error.style.display = 'none';

        try {
            updateProgress(10, 'Initializing generation...');
            const startTime = Date.now();

            const response = await fetch(`/web/api/avatar_dual.php?action=generate&mode=${payload.mode}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            updateProgress(50, 'Processing avatar...');
            const duration = Date.now() - startTime;

            debugLog('Avatar API response received', {
                status: response.status,
                statusText: response.statusText,
                ok: response.ok,
                contentType: response.headers.get('content-type'),
                duration: duration + 'ms'
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }

            const contentType = response.headers.get('content-type') || '';
            updateProgress(80, 'Processing response...');

            // FIXED: Handle different response types properly
            if (contentType.includes('multipart/x-mixed-replace')) {
                debugLog('Streaming response detected', { contentType });
                await handleStreamingResponse(response, video, videoInfo, payload, duration);

            } else if (contentType.includes('video')) {
                debugLog('Regular video response', { contentType });
                const blob = await response.blob();
                const videoUrl = URL.createObjectURL(blob);

                if (video) video.src = videoUrl;
                if (videoInfo) {
                    videoInfo.innerHTML = `
                            <strong>Generation Complete!</strong><br>
                            Mode: ${payload.mode}<br>
                            Size: ${(blob.size / 1024 / 1024).toFixed(2)} MB<br>
                            Type: ${contentType}<br>
                            Duration: ${(duration / 1000).toFixed(1)}s
                        `;
                }

            } else if (contentType.includes('json')) {
                const jsonData = await response.json();
                debugLog('JSON response received', jsonData);

                if (jsonData.type === 'websocket_info') {
                    showNotification('WebSocket streaming info received', 'info');
                    if (error) {
                        error.innerHTML = `<strong>WebSocket Streaming:</strong><br>
                                Connect to: ${jsonData.websocket_url}<br>
                                <small>Check console for connection details</small>`;
                        error.style.display = 'block';
                    }
                } else {
                    throw new Error('Unexpected JSON response: ' + JSON.stringify(jsonData));
                }

            } else {
                const text = await response.text();
                debugLog('Unexpected response', { contentType, text: text.substring(0, 500) });
                throw new Error('Unexpected response type: ' + contentType);
            }

            if (result) result.style.display = 'block';
            updateProgress(100, 'Complete!');
            showNotification('Avatar generated successfully!', 'success');

        } catch (err) {
            debugLog('Avatar generation error', { error: err.message });
            if (error) {
                error.textContent = 'Generation Error: ' + err.message;
                error.style.display = 'block';
            }
            showNotification('Avatar generation failed: ' + err.message, 'error');

        } finally {
            generationInProgress = false;
            if (loading) {
                loading.style.display = 'none';
                loading.classList.remove('show');
            }
        }
    }

    // FIXED: Streaming response handler
    async function handleStreamingResponse(response, video, videoInfo, payload, duration) {
        const reader = response.body.getReader();
        let buffer = new Uint8Array();
        let chunks = [];
        let videoFrames = [];
        let videoChunks = [];

        try {
            debugLog('Starting streaming response processing');

            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    debugLog('Stream reading complete');
                    break;
                }

                // Append new data to buffer
                const newBuffer = new Uint8Array(buffer.length + value.length);
                newBuffer.set(buffer);
                newBuffer.set(value, buffer.length);
                buffer = newBuffer;

                // FIXED: Process multipart boundaries properly
                buffer = await processMultipartBuffer(buffer, chunks, videoFrames, videoChunks);
            }

            // FIXED: Handle different streaming results
            await handleStreamingResults(video, videoInfo, chunks, videoFrames, videoChunks, payload, duration);

        } catch (streamError) {
            debugLog('Streaming error', { error: streamError.message, stack: streamError.stack });
            throw new Error('Streaming processing failed: ' + streamError.message);
        }
    }

    // FIXED: Process multipart buffer
    async function processMultipartBuffer(buffer, chunks, videoFrames, videoChunks) {
        const bufferString = new TextDecoder('latin1').decode(buffer);
        const boundaryPattern = /--frame\r?\n/g;
        let lastProcessedIndex = 0;
        let match;

        while ((match = boundaryPattern.exec(bufferString)) !== null) {
            const frameStart = lastProcessedIndex;
            const frameEnd = match.index;

            if (frameStart < frameEnd) {
                const frameData = buffer.slice(frameStart, frameEnd);
                await processStreamFrame(frameData, chunks, videoFrames, videoChunks);
            }

            lastProcessedIndex = boundaryPattern.lastIndex;
        }

        // Return remaining buffer
        return lastProcessedIndex > 0 ? buffer.slice(lastProcessedIndex) : buffer;
    }

    // FIXED: Process individual stream frame
    async function processStreamFrame(frameData, chunks, videoFrames, videoChunks) {
        try {
            const frameString = new TextDecoder('utf-8').decode(frameData);
            const headerEnd = frameString.indexOf('\r\n\r\n');

            if (headerEnd === -1) return;

            const headers = frameString.substring(0, headerEnd);
            const contentStart = headerEnd + 4;
            const contentData = frameData.slice(contentStart);

            const contentTypeMatch = headers.match(/Content-Type:\s*([^\r\n]+)/i);
            const contentType = contentTypeMatch ? contentTypeMatch[1].trim() : '';

            debugLog('Processing frame', {
                contentType,
                contentSize: contentData.length,
                hasHeaders: headers.length > 0
            });

            if (contentType === 'application/json') {
                // FIXED: Parse JSON metadata properly
                const jsonString = new TextDecoder('utf-8').decode(contentData).trim();
                if (jsonString) {
                    const chunkData = JSON.parse(jsonString);
                    chunks.push(chunkData);

                    debugLog('Chunk metadata received', {
                        chunkId: chunkData.chunk_id,
                        ready: chunkData.ready,
                        hasVideoUrl: !!chunkData.video_url
                    });

                    // Handle video chunk URLs
                    if (chunkData.video_url && chunkData.ready) {
                        videoChunks.push({
                            id: chunkData.chunk_id || videoChunks.length,
                            url: chunkData.video_url,
                            duration: chunkData.duration || 3,
                            sentence: chunkData.sentence || `Chunk ${chunkData.chunk_id || videoChunks.length}`
                        });
                    }
                }

            } else if (contentType.includes('image/jpeg') || contentType.includes('image/jpg')) {
                // Handle JPEG frames
                if (contentData.length > 1000) { // Only substantial frames
                    videoFrames.push(contentData);
                    debugLog('JPEG frame added', { frameCount: videoFrames.length, size: contentData.length });
                }

            } else if (contentType.includes('video/mp4') || contentType.includes('application/octet-stream')) {
                // Handle video data
                if (contentData.length > 1000) { // Only substantial video data
                    videoFrames.push(contentData);
                    debugLog('Video frame added', { frameCount: videoFrames.length, size: contentData.length });
                }
            }

        } catch (parseError) {
            debugLog('Frame parsing error', {
                error: parseError.message,
                frameSize: frameData.length
            });
        }
    }

    // FIXED: Handle streaming results
    async function handleStreamingResults(video, videoInfo, chunks, videoFrames, videoChunks, payload, duration) {
        debugLog('Processing streaming results', {
            chunkCount: chunks.length,
            videoFrameCount: videoFrames.length,
            videoChunkCount: videoChunks.length
        });

        if (videoChunks.length > 0) {
            // FIXED: Play video chunks sequentially
            debugLog('Playing video chunks sequentially', { chunkCount: videoChunks.length });
            await playVideoChunksSequentially(video, videoChunks);

        } else if (videoFrames.length > 0) {
            // Handle video frames
            const lastFrame = videoFrames[videoFrames.length - 1];

            // Check if it's JPEG frames or video data
            const frameHeader = new Uint8Array(lastFrame.slice(0, 4));
            const isJpeg = frameHeader[0] === 0xFF && frameHeader[1] === 0xD8;

            if (isJpeg && videoFrames.length > 1) {
                debugLog('Creating JPEG animation', { frameCount: videoFrames.length });
                createJpegAnimation(video, videoFrames);
            } else {
                // Treat as video data
                const videoBlob = new Blob([lastFrame], { type: 'video/mp4' });
                const videoUrl = URL.createObjectURL(videoBlob);

                if (video) {
                    video.src = videoUrl;
                    video.style.display = 'block';

                    // Remove any existing canvas
                    const existingCanvas = video.parentNode.querySelector('.jpeg-animation-canvas');
                    if (existingCanvas) {
                        existingCanvas.remove();
                    }
                }
            }
        } else {
            debugLog('No video content received');
            showNotification('No video content received in stream', 'warning');
        }

        // Update video info
        if (videoInfo) {
            videoInfo.innerHTML = `
                    <strong>Streaming Complete!</strong><br>
                    Mode: Streaming (${payload.stream_mode})<br>
                    Chunks: ${chunks.length}<br>
                    Video Frames: ${videoFrames.length}<br>
                    Video Chunks: ${videoChunks.length}<br>
                    Total Duration: ${chunks.reduce((sum, c) => sum + (c.duration || 0), 0).toFixed(2)}s<br>
                    Stream Time: ${(duration / 1000).toFixed(1)}s
                `;
        }
    }

    // FIXED: Play video chunks sequentially
    async function playVideoChunksSequentially(video, videoChunks) {
        if (!video || videoChunks.length === 0) return;

        // Sort chunks by ID
        videoChunks.sort((a, b) => (a.id || 0) - (b.id || 0));

        // Hide any existing canvas
        const existingCanvas = video.parentNode.querySelector('.jpeg-animation-canvas');
        if (existingCanvas) {
            existingCanvas.style.display = 'none';
        }

        video.style.display = 'block';
        let currentChunkIndex = 0;

        const playNextChunk = async () => {
            if (currentChunkIndex >= videoChunks.length) {
                debugLog('All video chunks played');
                showNotification('Video playback complete!', 'success');
                return;
            }

            const chunk = videoChunks[currentChunkIndex];
            debugLog('Playing video chunk', {
                chunkId: chunk.id,
                url: chunk.url,
                duration: chunk.duration
            });

            try {
                // Update video source
                video.src = chunk.url;

                // Wait for video to load and play
                await new Promise((resolve, reject) => {
                    video.onloadeddata = () => {
                        video.play().then(resolve).catch(reject);
                    };
                    video.onerror = () => reject(new Error('Video load error'));

                    // Timeout after 10 seconds
                    setTimeout(() => reject(new Error('Video load timeout')), 10000);
                });

                showNotification(`Playing chunk ${currentChunkIndex + 1}/${videoChunks.length}: "${chunk.sentence.substring(0, 30)}..."`, 'info', 1000);

                // Wait for video to end
                await new Promise((resolve) => {
                    video.onended = resolve;
                    // Also resolve after expected duration + buffer
                    setTimeout(resolve, (chunk.duration + 1) * 1000);
                });

            } catch (error) {
                debugLog('Video chunk play error', { error: error.message, chunkId: chunk.id });
                showNotification(`Error playing chunk ${currentChunkIndex + 1}`, 'error', 1000);
            }

            currentChunkIndex++;
            // Small delay before next chunk
            setTimeout(playNextChunk, 200);
        };

        // Start playing
        await playNextChunk();
    }

    // FIXED: Create JPEG animation
    function createJpegAnimation(video, videoFrames) {
        if (!video || videoFrames.length === 0) return;

        // Hide video element
        video.style.display = 'none';

        // Create or get canvas
        let canvas = video.parentNode.querySelector('.jpeg-animation-canvas');
        if (!canvas) {
            canvas = document.createElement('canvas');
            canvas.className = 'jpeg-animation-canvas';
            video.parentNode.insertBefore(canvas, video);
        }

        canvas.style.display = 'block';
        const ctx = canvas.getContext('2d');

        let currentFrameIndex = 0;
        let animationPlaying = false;
        let animationInterval;

        // Load first frame to set canvas size
        const firstFrameBlob = new Blob([videoFrames[0]], { type: 'image/jpeg' });
        const firstFrameUrl = URL.createObjectURL(firstFrameBlob);

        const firstImg = new Image();
        firstImg.onload = function() {
            canvas.width = firstImg.width;
            canvas.height = firstImg.height;
            ctx.drawImage(firstImg, 0, 0);

            // Add play button
            drawPlayButton(ctx, canvas.width, canvas.height);
            URL.revokeObjectURL(firstFrameUrl);

            debugLog('JPEG animation canvas ready', {
                width: canvas.width,
                height: canvas.height,
                frameCount: videoFrames.length
            });
        };
        firstImg.src = firstFrameUrl;

        // Play button drawing
        function drawPlayButton(context, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.08;

            // Semi-transparent background
            context.fillStyle = 'rgba(0, 0, 0, 0.6)';
            context.beginPath();
            context.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            context.fill();

            // Play triangle
            context.fillStyle = 'white';
            context.beginPath();
            context.moveTo(centerX - radius * 0.3, centerY - radius * 0.4);
            context.lineTo(centerX + radius * 0.4, centerY);
            context.lineTo(centerX - radius * 0.3, centerY + radius * 0.4);
            context.closePath();
            context.fill();
        }

        // Click handler for play/pause
        canvas.onclick = function() {
            if (animationPlaying) {
                // Pause
                clearInterval(animationInterval);
                animationPlaying = false;
                drawPlayButton(ctx, canvas.width, canvas.height);
                showNotification('Animation paused', 'info');
            } else {
                // Play
                animationPlaying = true;
                currentFrameIndex = 0;
                const fps = 15;
                const frameDuration = 1000 / fps;

                debugLog('Starting JPEG animation', { fps, frameCount: videoFrames.length });
                showNotification('Animation started - Click to pause', 'success');

                animationInterval = setInterval(() => {
                    if (currentFrameIndex >= videoFrames.length) {
                        currentFrameIndex = 0; // Loop
                    }

                    const frameData = videoFrames[currentFrameIndex];
                    const frameBlob = new Blob([frameData], { type: 'image/jpeg' });
                    const frameUrl = URL.createObjectURL(frameBlob);

                    const frameImg = new Image();
                    frameImg.onload = function() {
                        if (animationPlaying) {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(frameImg, 0, 0);
                        }
                        URL.revokeObjectURL(frameUrl);
                    };
                    frameImg.src = frameUrl;

                    currentFrameIndex++;
                }, frameDuration);
            }
        };

        // Hover effects
        canvas.onmouseover = () => canvas.style.opacity = '0.9';
        canvas.onmouseout = () => canvas.style.opacity = '1.0';
    }

    // Video Management Functions
    function downloadVideo() {
        const video = document.getElementById('avatarVideo');
        if (video && video.src) {
            const a = document.createElement('a');
            a.href = video.src;
            a.download = `avatar_${new Date().getTime()}.mp4`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showNotification('Video download started', 'success');
        } else {
            showNotification('No video available to download', 'error');
        }
    }

    function shareVideo() {
        const video = document.getElementById('avatarVideo');
        if (video && video.src) {
            if (navigator.share) {
                navigator.share({
                    title: 'Generated Avatar Video',
                    text: 'Check out this AI-generated avatar!',
                    url: video.src
                }).then(() => {
                    showNotification('Video shared successfully', 'success');
                }).catch(() => {
                    showNotification('Sharing failed', 'error');
                });
            } else {
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(video.src).then(() => {
                        showNotification('Video URL copied to clipboard', 'success');
                    }).catch(() => {
                        showNotification('Could not copy URL', 'error');
                    });
                } else {
                    showNotification('Sharing not supported', 'error');
                }
            }
        } else {
            showNotification('No video available to share', 'error');
        }
    }

    // API Functions
    async function testMP4() {
        debugLog('Testing MP4 pipeline');
        const video = document.getElementById('avatarVideo');
        const result = document.getElementById('result');
        const error = document.getElementById('error');

        try {
            const response = await fetch('/test-mp4');
            if (response.ok) {
                const blob = await response.blob();
                const videoUrl = URL.createObjectURL(blob);

                if (video) video.src = videoUrl;
                if (result) result.style.display = 'block';
                if (error) error.style.display = 'none';

                showNotification('Test MP4 loaded successfully', 'success');
            } else {
                throw new Error(`Test MP4 failed: ${response.status}`);
            }
        } catch (err) {
            debugLog('Test MP4 failed', { error: err.message });
            if (error) {
                error.textContent = 'Test MP4 Error: ' + err.message;
                error.style.display = 'block';
            }
            showNotification('Test MP4 failed', 'error');
        }
    }

    async function testConnection() {
        debugLog('Testing avatar service connection');
        try {
            const response = await fetch('/web/api/avatar_dual.php?action=test');
            const result = await response.json();

            if (result.status === 'success') {
                showNotification('Connection successful: ' + result.message, 'success');
            } else {
                showNotification('Connection failed: ' + result.message, 'error');
            }
        } catch (error) {
            debugLog('Connection test error', { error: error.message });
            showNotification('Connection test failed: ' + error.message, 'error');
        }
    }

    async function getEngines() {
        debugLog('Getting TTS engines');
        try {
            const response = await fetch('/web/api/avatar_dual.php?action=engines');
            const result = await response.json();

            if (result.engines) {
                debugLog('TTS engines received', result.engines);
                let info = "Available TTS Engines:\n\n";
                Object.entries(result.engines).forEach(([key, engine]) => {
                    info += `${engine.name}:\n`;
                    info += `  Voices: ${engine.voices ? engine.voices.length : 'Unknown'}\n\n`;
                });
                alert(info);
            } else {
                showNotification('No engine data received', 'warning');
            }
        } catch (error) {
            showNotification('Failed to get TTS engines: ' + error.message, 'error');
        }
    }

    async function getStatus() {
        debugLog('Getting system status');
        try {
            const response = await fetch('/web/api/avatar_dual.php?action=status');
            const result = await response.json();
            debugLog('System status received', result);
            showNotification('Status retrieved successfully', 'success');
        } catch (error) {
            showNotification('Failed to get system status', 'error');
        }
    }

    async function getLogs() {
        debugLog('Getting logs');
        try {
            const response = await fetch('/web/api/avatar_dual.php?action=logs');
            const result = await response.json();

            const container = document.getElementById('logContainer');
            if (container && result.data && result.data.logs) {
                const logText = Array.isArray(result.data.logs) ? result.data.logs.join('\n') : result.data.logs;
                container.innerHTML = logText;
            }
            showNotification('Logs retrieved successfully', 'success');
        } catch (error) {
            showNotification('Failed to retrieve logs', 'error');
        }
    }

    function clearLogs() {
        const container = document.getElementById('logContainer');
        if (container) {
            container.innerHTML = 'Logs cleared';
        }
        showNotification('Logs cleared', 'info');
    }

    // Initialize
    function initializeDebugConsole() {
        debugLog('Avatar Debug Console with Fixed Streaming initializing');

        // Mode change handler
        const modeRadios = document.querySelectorAll('input[name="mode"]');
        modeRadios.forEach(radio => {
            radio.addEventListener('change', function() {
                currentMode = this.value;
                debugLog('Mode changed', { mode: currentMode });
            });
        });

        debugLog('Initialization complete - Streaming fixes applied');
        showNotification('Avatar Debug Console initialized with streaming fixes', 'success');
    }

    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeDebugConsole);
    } else {
        initializeDebugConsole();
    }
</script>
</body>
</html>